{
  "language": "Solidity",
  "sources": {
    "data/source/lib/ECVerify.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n/* solium-disable error-reason */\r\npragma solidity 0.7.6;\r\n\r\nlibrary ECVerify {\r\n\r\n    function ecverify(bytes32 hash, bytes memory signature)\r\n        internal\r\n        pure\r\n        returns (address signature_address)\r\n    {\r\n        require(signature.length == 65);\r\n\r\n        bytes32 r;\r\n        bytes32 s;\r\n        uint8 v;\r\n\r\n        // The signature format is a compact form of:\r\n        //   {bytes32 r}{bytes32 s}{uint8 v}\r\n        // Compact means, uint8 is not padded to 32 bytes.\r\n        assembly { // solium-disable-line security/no-inline-assembly\r\n            r := mload(add(signature, 32))\r\n            s := mload(add(signature, 64))\r\n\r\n            // Here we are loading the last 32 bytes, including 31 bytes following the signature.\r\n            v := byte(0, mload(add(signature, 96)))\r\n        }\r\n\r\n        // Version of signature should be 27 or 28, but 0 and 1 are also possible\r\n        if (v < 27) {\r\n            v += 27;\r\n        }\r\n\r\n        require(v == 27 || v == 28);\r\n\r\n        signature_address = ecrecover(hash, v, r, s);\r\n\r\n        // ecrecover returns zero on error\r\n        require(signature_address != address(0x0));\r\n\r\n        return signature_address;\r\n    }\r\n}\r\n"
    },
    "data/source/services/OneToN.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.7.6;\n\nimport \"../lib/ECVerify.sol\";\nimport \"../lib/MessageType.sol\";\nimport \"../raiden/Utils.sol\";\nimport \"./ServiceRegistry.sol\";\nimport \"./UserDeposit.sol\";\n\ncontract OneToN is Utils {\n    UserDeposit public deposit_contract;\n    ServiceRegistry public service_registry_contract;\n\n    // The signature given to claim() has to be computed with\n    // this chain_id.  Otherwise the call fails.\n    uint256 public chain_id;\n\n    // Indicates which sessions have already been settled by storing\n    // keccak256(receiver, sender, expiration_block) => expiration_block.\n    mapping (bytes32 => uint256) public settled_sessions;\n\n    /*\n     *  Events\n     */\n\n    // The session has been settled and can't be claimed again. The receiver is\n    // indexed to allow services to know when claims have been successfully\n    // processed.\n    // When users want to get notified about low balances, they should listen\n    // for UserDeposit.BalanceReduced, instead.\n    // The first three values identify the session, `transferred` is the amount\n    // of tokens that has actually been transferred during the claim.\n    event Claimed(\n        address sender,\n        address indexed receiver,\n        uint256 expiration_block,\n        uint256 transferred\n    );\n\n    /*\n     *  Constructor\n     */\n\n    /// @param _deposit_contract Address of UserDeposit contract\n    /// @param _service_registry_contract Address of ServiceRegistry contract\n    constructor(\n        address _deposit_contract,\n        uint256 _chain_id,\n        address _service_registry_contract\n    ) {\n        deposit_contract = UserDeposit(_deposit_contract);\n        chain_id = _chain_id;\n        service_registry_contract = ServiceRegistry(_service_registry_contract);\n    }\n\n    /// @notice Submit an IOU to claim the owed amount.\n    /// If the deposit is smaller than the claim, the remaining deposit is\n    /// claimed. If no tokens are claimed, `claim` may be retried, later.\n    /// @param sender Address from which the amount is transferred\n    /// @param receiver Address to which the amount is transferred\n    /// @param amount Owed amount of tokens\n    /// @param expiration_block Tokens can only be claimed before this time\n    /// @param one_to_n_address Address of this contract\n    /// @param signature Sender's signature over keccak256(sender, receiver, amount, expiration_block)\n    /// @return Amount of transferred tokens\n    function claim(\n        address sender,\n        address receiver,\n        uint256 amount,\n        uint256 expiration_block,\n        address one_to_n_address,\n        bytes memory signature\n    )\n        public\n        returns (uint)\n    {\n        require(service_registry_contract.hasValidRegistration(receiver), \"receiver not registered\");\n        require(block.number <= expiration_block, \"IOU expired\");\n\n        // validate signature\n        address addressFromSignature = recoverAddressFromSignature(\n            sender,\n            receiver,\n            amount,\n            expiration_block,\n            chain_id,\n            signature\n        );\n        require(addressFromSignature == sender, \"Signature mismatch\");\n\n        // must not be claimed before\n        bytes32 _key = keccak256(abi.encodePacked(receiver, sender, expiration_block));\n        require(settled_sessions[_key] == 0, \"Already settled session\");\n\n        // claim as much as possible\n        uint256 transferable = min(amount, deposit_contract.balances(sender));\n        if (transferable > 0) {\n            // register to avoid double claiming\n            settled_sessions[_key] = expiration_block;\n            assert(expiration_block > 0);\n            emit Claimed(sender, receiver, expiration_block, transferable);\n\n            require(deposit_contract.transfer(sender, receiver, transferable), \"deposit did not transfer\");\n        }\n        return transferable;\n    }\n\n    /// @notice Submit multiple IOUs to claim the owed amount.\n    /// This is the same as calling `claim` multiple times, except for the reduced gas cost.\n    /// @param senders Addresses from which the amounts are transferred\n    /// @param receivers Addresses to which the amounts are transferred\n    /// @param amounts Owed amounts of tokens\n    /// @param expiration_blocks Tokens can only be claimed before this time\n    /// @param one_to_n_address Address of this contract\n    /// @param signatures Sender's signatures concatenated into a single bytes array\n    /// @return Amount of transferred tokens\n    function bulkClaim(\n        address[] calldata senders,\n        address[] calldata receivers,\n        uint256[] calldata amounts,\n        uint256[] calldata expiration_blocks,\n        address one_to_n_address,\n        bytes calldata signatures\n    )\n        external\n        returns (uint)\n    {\n        uint256 transferable = 0;\n        require(\n            senders.length == receivers.length &&\n            senders.length == amounts.length &&\n            senders.length == expiration_blocks.length,\n            \"Same number of elements required for all input parameters\"\n        );\n        require(\n            signatures.length == senders.length * 65,\n            \"`signatures` should contain 65 bytes per IOU\"\n        );\n        for (uint256 i = 0; i < senders.length; i++) {\n            transferable += claim(\n                senders[i],\n                receivers[i],\n                amounts[i],\n                expiration_blocks[i],\n                one_to_n_address,\n                getSingleSignature(signatures, i)\n            );\n        }\n        return transferable;\n    }\n\n    /*\n     *  Internal Functions\n     */\n\n    /// @notice Get a single signature out of a byte array that contains concatenated signatures.\n    /// @param signatures Multiple signatures concatenated into a single byte array\n    /// @param i Index of the requested signature (zero based; the caller must check ranges)\n    function getSingleSignature(\n        bytes memory signatures,\n        uint256 i\n    )\n        internal\n        pure\n        returns (bytes memory)\n    {\n        assert(i < signatures.length);\n        uint256 offset = i * 65;\n        // We need only 65, but we can access only whole words, so the next usable size is 3 * 32.\n        bytes memory signature = new bytes(96);\n        assembly { // solium-disable-line security/no-inline-assembly\n            // Copy the 96 bytes, using `offset` to start at the beginning\n            // of the requested signature.\n            mstore(add(signature, 32), mload(add(add(signatures, 32), offset)))\n            mstore(add(signature, 64), mload(add(add(signatures, 64), offset)))\n            mstore(add(signature, 96), mload(add(add(signatures, 96), offset)))\n\n            // The first 32 bytes store the length of the dynamic array.\n            // Since a signature is 65 bytes, we set the length to 65, so\n            // that only the signature is returned.\n            mstore(signature, 65)\n        }\n        return signature;\n    }\n\n    function recoverAddressFromSignature(\n        address sender,\n        address receiver,\n        uint256 amount,\n        uint256 expiration_block,\n        uint256 chain_id,\n        bytes memory signature\n    )\n        internal\n        view\n        returns (address signature_address)\n    {\n        bytes32 message_hash = keccak256(\n            abi.encodePacked(\n                \"\\x19Ethereum Signed Message:\\n188\",\n                address(this),\n                chain_id,\n                uint256(MessageType.MessageTypeId.IOU),\n                sender,\n                receiver,\n                amount,\n                expiration_block\n            )\n        );\n        return ECVerify.ecverify(message_hash, signature);\n    }\n\n    function min(uint256 a, uint256 b) internal pure returns (uint256)\n    {\n        return a > b ? b : a;\n    }\n\n}\n\n\n// MIT License\n\n// Copyright (c) 2018\n\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n\n// The above copyright notice and this permission notice shall be included in all\n// copies or substantial portions of the Software.\n\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n// SOFTWARE."
    },
    "data/source/lib/MessageType.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n/* solium-disable error-reason */\r\npragma solidity 0.7.6;\r\n\r\nlibrary MessageType {\r\n\r\n    enum MessageTypeId {\r\n        None,\r\n        BalanceProof,\r\n        BalanceProofUpdate,\r\n        Withdraw,\r\n        CooperativeSettle,\r\n        IOU,\r\n        MSReward\r\n    }\r\n}\r\n"
    },
    "data/source/raiden/Utils.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity 0.7.6;\r\n\r\n/// @title Utils\r\n/// @notice Utils contract for various helpers used by the Raiden Network smart\r\n/// contracts.\r\ncontract Utils {\r\n    /// @notice Check if a contract exists\r\n    /// @param contract_address The address to check whether a contract is\r\n    /// deployed or not\r\n    /// @return True if a contract exists, false otherwise\r\n    function contractExists(address contract_address) public view returns (bool) {\r\n        uint size;\r\n\r\n        assembly { // solium-disable-line security/no-inline-assembly\r\n            size := extcodesize(contract_address)\r\n        }\r\n\r\n        return size > 0;\r\n    }\r\n}\r\n"
    },
    "data/source/services/ServiceRegistry.sol": {
      "content": "// SPDX-License-Identifier: MIT\n/* solium-disable indentation */\n/* solium-disable security/no-block-members */\npragma solidity 0.7.6;\n\nimport \"../raiden/Token.sol\";\nimport \"../raiden/Utils.sol\";\n\ncontract ServiceRegistryConfigurableParameters {\n    address public controller;\n\n    modifier onlyController() {\n        require(msg.sender == controller, \"caller is not the controller\");\n        _;\n    }\n\n    // After a price is set to set_price at timestamp set_price_at,\n    // the price decays according to decayedPrice().\n    uint256 public set_price;\n    uint256 public set_price_at;\n\n    /// The amount of time (in seconds) till the price decreases to roughly 1/e.\n    uint256 public decay_constant = 200 days;\n\n    // Once the price is at min_price, it can't decay further.\n    uint256 public min_price = 1000;\n\n    // Whenever a deposit comes in, the price is multiplied by numerator / denominator.\n    uint256 public price_bump_numerator = 1;\n    uint256 public price_bump_denominator = 1;\n\n    // The duration of service registration/extension in seconds\n    uint256 public registration_duration = 180 days;\n\n    // If true, new deposits are no longer accepted.\n    bool public deprecated = false;\n\n    function setDeprecationSwitch() public onlyController returns (bool _success) {\n        deprecated = true;\n        return true;\n    }\n\n    function changeParameters(\n            uint256 _price_bump_numerator,\n            uint256 _price_bump_denominator,\n            uint256 _decay_constant,\n            uint256 _min_price,\n            uint256 _registration_duration\n    ) public onlyController returns (bool _success) {\n        changeParametersInternal(\n            _price_bump_numerator,\n            _price_bump_denominator,\n            _decay_constant,\n            _min_price,\n            _registration_duration\n        );\n        return true;\n    }\n\n    function changeParametersInternal(\n            uint256 _price_bump_numerator,\n            uint256 _price_bump_denominator,\n            uint256 _decay_constant,\n            uint256 _min_price,\n            uint256 _registration_duration\n    ) internal {\n        refreshPrice();\n        setPriceBumpParameters(_price_bump_numerator, _price_bump_denominator);\n        setMinPrice(_min_price);\n        setDecayConstant(_decay_constant);\n        setRegistrationDuration(_registration_duration);\n    }\n\n    // Updates set_price to be currentPrice() and set_price_at to be now\n    function refreshPrice() private {\n        set_price = currentPrice();\n        set_price_at = block.timestamp;\n    }\n\n    function setPriceBumpParameters(\n            uint256 _price_bump_numerator,\n            uint256 _price_bump_denominator\n    ) private {\n        require(_price_bump_denominator > 0, \"divide by zero\");\n        require(_price_bump_numerator >= _price_bump_denominator, \"price dump instead of bump\");\n        require(_price_bump_numerator < 2 ** 40, \"price dump numerator is too big\");\n        price_bump_numerator = _price_bump_numerator;\n        price_bump_denominator = _price_bump_denominator;\n    }\n\n    function setMinPrice(uint256 _min_price) private {\n        // No checks.  Even allowing zero.\n        min_price = _min_price;\n        // No checks or modifications on set_price.\n        // Even if set_price is smaller than min_price, currentPrice() function returns min_price.\n    }\n\n    function setDecayConstant(uint256 _decay_constant) private {\n        require(_decay_constant > 0, \"attempt to set zero decay constant\");\n        require(_decay_constant < 2 ** 40, \"too big decay constant\");\n        decay_constant = _decay_constant;\n    }\n\n    function setRegistrationDuration(uint256 _registration_duration) private {\n        // No checks.  Even allowing zero (when no new registrations are possible).\n        registration_duration = _registration_duration;\n    }\n\n\n    /// @notice The amount to deposit for registration or extension\n    /// Note: the price moves quickly depending on what other addresses do.\n    /// The current price might change after you send a `deposit()` transaction\n    /// before the transaction is executed.\n    function currentPrice() public view returns (uint256) {\n        require(block.timestamp >= set_price_at, \"An underflow in price computation\");\n        uint256 seconds_passed = block.timestamp - set_price_at;\n\n        return decayedPrice(set_price, seconds_passed);\n    }\n\n\n    /// @notice Calculates the decreased price after a number of seconds\n    /// @param _set_price The initial price\n    /// @param _seconds_passed The number of seconds passed since the initial\n    /// price was set\n    function decayedPrice(uint256 _set_price, uint256 _seconds_passed) public\n        view returns (uint256) {\n        // We are here trying to approximate some exponential decay.\n        // exp(- X / A) where\n        //   X is the number of seconds since the last price change\n        //   A is the decay constant (A = 200 days corresponds to 0.5% decrease per day)\n\n        // exp(- X / A) ~~ P / Q where\n        //   P = 24 A^4\n        //   Q = 24 A^4 + 24 A^3X + 12 A^2X^2 + 4 AX^3 + X^4\n        // Note: swap P and Q, and then think about the Taylor expansion.\n\n        uint256 X = _seconds_passed;\n\n        if (X >= 2 ** 40) { // The computation below overflows.\n            return min_price;\n        }\n\n        uint256 A = decay_constant;\n\n        uint256 P = 24 * (A ** 4);\n        uint256 Q = P + 24*(A**3)*X + 12*(A**2)*(X**2) + 4*A*(X**3) + X**4;\n\n        // The multiplication below is not supposed to overflow because\n        // _set_price should be at most 2 ** 90 and\n        // P should be at most 24 * (2 ** 40).\n        uint256 price = _set_price * P / Q;\n\n        // Not allowing a price smaller than min_price.\n        // Once it's too low it's too low forever.\n        if (price < min_price) {\n            price = min_price;\n        }\n        return price;\n    }\n}\n\n\ncontract Deposit {\n    // This contract holds ERC20 tokens as deposit until a predetemined point of time.\n\n    // The ERC20 token contract that the deposit is about.\n    Token public token;\n\n    // The address of ServiceRegistry contract that this deposit is associated with.\n    // If the address has no code, service_registry.deprecated() call will fail.\n    ServiceRegistryConfigurableParameters service_registry;\n\n    // The address that can withdraw the deposit after the release time.\n    address public withdrawer;\n\n    // The timestamp after which the withdrawer can withdraw the deposit.\n    uint256 public release_at;\n\n    /// @param _token The address of the ERC20 token contract where the deposit is accounted\n    /// @param _release_at The timestap after which the withdrawer can withdraw the deposit\n    /// @param _withdrawer The address that can withdraw the deposit after the release time\n    /// @param _service_registry The address of ServiceRegistry whose deprecation enables immediate withdrawals\n    constructor(\n        Token _token,\n        uint256 _release_at,\n        address _withdrawer,\n        ServiceRegistryConfigurableParameters _service_registry\n    ) {\n        token = _token;\n        // Don't care even if it's in the past.\n        release_at = _release_at;\n        withdrawer = _withdrawer;\n        service_registry = _service_registry;\n    }\n\n    // In order to make a deposit, transfer the ERC20 token into this contract.\n    // If you transfer a wrong kind of ERC20 token or ETH into this contract,\n    // these tokens will be lost forever.\n\n    /// @notice Withdraws the tokens that have been deposited\n    /// Only `withdrawer` can call this.\n    /// @param _to The address where the withdrawn tokens should go\n    function withdraw(address payable _to) external {\n        uint256 balance = token.balanceOf(address(this));\n        require(msg.sender == withdrawer, \"the caller is not the withdrawer\");\n        require(block.timestamp >= release_at || service_registry.deprecated(), \"deposit not released yet\");\n        require(balance > 0, \"nothing to withdraw\");\n        require(token.transfer(_to, balance), \"token didn't transfer\");\n        //selfdestruct(_to); // OVM does not support selfdestruct\n    }\n}\n\n\ncontract ServiceRegistry is Utils, ServiceRegistryConfigurableParameters {\n    Token public token;\n\n    mapping(address => uint256) public service_valid_till;\n    mapping(address => string) public urls;  // URLs of services for HTTP access\n\n    // An append-only list of addresses that have ever made a deposit.\n    // Starting from this list, all alive registrations can be figured out.\n    address[] public ever_made_deposits;\n\n    // @param service The address of the registered service provider\n    // @param valid_till The timestamp of the moment when the registration expires\n    // @param deposit_amount The amount of deposit transferred\n    // @param deposit The address of Deposit instance where the deposit is stored\n    event RegisteredService(address indexed service, uint256 valid_till, uint256 deposit_amount, Deposit deposit_contract);\n\n    // @param _token_for_registration The address of the ERC20 token contract that services use for registration fees\n    // @param _controller The address that can change parameters and deprecate the ServiceRegistry\n    // @param _initial_price The amount of tokens needed initially for a slot\n    // @param _price_bump_numerator The ratio of price bump after deposit is made (numerator)\n    // @param _price_bump_denominator The ratio of price bump after deposit is made (denominator)\n    // @param _decay_constant The number of seconds after which the price becomes roughly 1/e\n    // @param _min_price The minimum amount of tokens needed for a slot\n    // @param _registration_duration The number of seconds (roughly, barring block time & miners'\n    // timestamp errors) of a slot gained for a successful deposit\n    constructor(\n            Token _token_for_registration,\n            address _controller,\n            uint256 _initial_price,\n            uint256 _price_bump_numerator,\n            uint256 _price_bump_denominator,\n            uint256 _decay_constant,\n            uint256 _min_price,\n            uint256 _registration_duration\n    ) {\n        require(address(_token_for_registration) != address(0x0), \"token at address zero\");\n        require(contractExists(address(_token_for_registration)), \"token has no code\");\n        require(_initial_price >= min_price, \"initial price too low\");\n        require(_initial_price <= 2 ** 90, \"intiial price too high\");\n\n        token = _token_for_registration;\n        // Check if the contract is indeed a token contract\n        require(token.totalSupply() > 0, \"total supply zero\");\n        controller = _controller;\n\n        // Set up the price and the set price timestamp\n        set_price = _initial_price;\n        set_price_at = block.timestamp;\n\n        // Set the parameters\n        changeParametersInternal(_price_bump_numerator, _price_bump_denominator, _decay_constant, _min_price, _registration_duration);\n    }\n\n    // @notice Locks tokens and registers a service or extends the registration\n    // @param _limit_amount The biggest amount of tokens that the caller is willing to deposit\n    // The call fails if the current price is higher (this is always possible\n    // when other parties have just called `deposit()`)\n    function deposit(uint _limit_amount) public returns (bool _success) {\n        require(! deprecated, \"this contract was deprecated\");\n\n        uint256 amount = currentPrice();\n        require(_limit_amount >= amount, \"not enough limit\");\n\n        // Extend the service position.\n        uint256 valid_till = service_valid_till[msg.sender];\n        if (valid_till == 0) { // a first time joiner\n            ever_made_deposits.push(msg.sender);\n        }\n        if (valid_till < block.timestamp) { // a first time joiner or an expired service.\n            valid_till = block.timestamp;\n        }\n        // Check against overflow.\n        require(valid_till < valid_till + registration_duration, \"overflow during extending the registration\");\n        valid_till = valid_till + registration_duration;\n        assert(valid_till > service_valid_till[msg.sender]);\n        service_valid_till[msg.sender] = valid_till;\n\n        // Record the price\n        set_price = amount * price_bump_numerator / price_bump_denominator;\n        if (set_price > 2 ** 90) {\n            set_price = 2 ** 90; // Preventing overflows.\n        }\n        set_price_at = block.timestamp;\n\n        // Move the deposit in a new Deposit contract.\n        assert(block.timestamp < valid_till);\n        Deposit depo = new Deposit(token, valid_till, msg.sender, this);\n        require(token.transferFrom(msg.sender, address(depo), amount), \"Token transfer for deposit failed\");\n\n        // Fire event\n        emit RegisteredService(msg.sender, valid_till, amount, depo);\n\n        return true;\n    }\n\n    /// @notice Sets the URL used to access a service via HTTP\n    /// Only a currently registered service can call this successfully\n    /// @param new_url The new URL string to be stored\n    function setURL(string memory new_url) public returns (bool _success) {\n        require(hasValidRegistration(msg.sender), \"registration expired\");\n        require(bytes(new_url).length != 0, \"new url is empty string\");\n        urls[msg.sender] = new_url;\n        return true;\n    }\n\n    /// A getter function for seeing the length of ever_made_deposits array\n    function everMadeDepositsLen() public view returns (uint256 _len) {\n        return ever_made_deposits.length;\n    }\n\n    function hasValidRegistration(address _address) public view returns (bool _has_registration) {\n        return block.timestamp < service_valid_till[_address];\n    }\n}\n\n\n// MIT License\n\n// Copyright (c) 2018\n\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n\n// The above copyright notice and this permission notice shall be included in all\n// copies or substantial portions of the Software.\n\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n// SOFTWARE."
    },
    "data/source/services/UserDeposit.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.7.6;\n\nimport \"../raiden/Token.sol\";\nimport \"../raiden/Utils.sol\";\n\ncontract UserDeposit is Utils {\n    uint constant public withdraw_delay = 100;  // time before withdraw is allowed in blocks\n\n    // Token to be used for the deposit\n    Token public token;\n\n    // Trusted contracts (can execute `transfer`)\n    address public msc_address;\n    address public one_to_n_address;\n\n    // Total amount of tokens that have been deposited. This is monotonous and\n    // doing a transfer or withdrawing tokens will not decrease total_deposit!\n    mapping(address => uint256) public total_deposit;\n    // Current user's balance, ignoring planned withdraws\n    mapping(address => uint256) public balances;\n    mapping(address => WithdrawPlan) public withdraw_plans;\n\n    // The sum of all balances\n    uint256 public whole_balance = 0;\n    // Deposit limit for this whole contract\n    uint256 public whole_balance_limit;\n\n    /*\n     *  Structs\n     */\n    struct WithdrawPlan {\n        uint256 amount;\n        uint256 withdraw_block;  // earliest block at which withdraw is allowed\n    }\n\n    /*\n     *  Events\n     */\n\n    event BalanceReduced(address indexed owner, uint newBalance);\n    event WithdrawPlanned(address indexed withdrawer, uint plannedBalance);\n\n    /*\n     *  Modifiers\n     */\n\n    modifier canTransfer() {\n        require(msg.sender == msc_address || msg.sender == one_to_n_address, \"unknown caller\");\n        _;\n    }\n\n    /*\n     *  Constructor\n     */\n\n    /// @notice Set the default values for the smart contract\n    /// @param _token_address The address of the token to use for rewards\n    constructor(address _token_address, uint256 _whole_balance_limit)\n    {\n        // check token contract\n        require(_token_address != address(0x0), \"token at address zero\");\n        require(contractExists(_token_address), \"token has no code\");\n        token = Token(_token_address);\n        require(token.totalSupply() > 0, \"token has no total supply\"); // Check if the contract is indeed a token contract\n        // check and set the whole balance limit\n        require(_whole_balance_limit > 0, \"whole balance limit is zero\");\n        whole_balance_limit = _whole_balance_limit;\n    }\n\n    /// @notice Specify trusted contracts. This has to be done outside of the\n    /// constructor to avoid cyclic dependencies.\n    /// @param _msc_address Address of the MonitoringService contract\n    /// @param _one_to_n_address Address of the OneToN contract\n    function init(address _msc_address, address _one_to_n_address)\n        external\n    {\n        // prevent changes of trusted contracts after initialization\n        require(msc_address == address(0x0) && one_to_n_address == address(0x0), \"already initialized\");\n\n        // check monitoring service contract\n        require(_msc_address != address(0x0), \"MS contract at address zero\");\n        require(contractExists(_msc_address), \"MS contract has no code\");\n        msc_address = _msc_address;\n\n        // check one to n contract\n        require(_one_to_n_address != address(0x0), \"OneToN at address zero\");\n        require(contractExists(_one_to_n_address), \"OneToN has no code\");\n        one_to_n_address = _one_to_n_address;\n    }\n\n    /// @notice Deposit tokens. The amount of transferred tokens will be\n    /// `new_total_deposit - total_deposit[beneficiary]`. This makes the\n    /// function behavior predictable and idempotent. Can be called several\n    /// times and on behalf of other accounts.\n    /// @param beneficiary The account benefiting from the deposit\n    /// @param new_total_deposit The total sum of tokens that have been\n    /// deposited by the user by calling this function.\n    function deposit(address beneficiary, uint256 new_total_deposit)\n        external\n    {\n        require(new_total_deposit > total_deposit[beneficiary], \"deposit not increasing\");\n\n        // Calculate the actual amount of tokens that will be transferred\n        uint256 added_deposit = new_total_deposit - total_deposit[beneficiary];\n\n        balances[beneficiary] += added_deposit;\n        total_deposit[beneficiary] += added_deposit;\n\n        // Update whole_balance, but take care against overflows.\n        require(whole_balance + added_deposit >= whole_balance, \"overflowing deposit\");\n        whole_balance += added_deposit;\n\n        // Decline deposit if the whole balance is bigger than the limit.\n        require(whole_balance <= whole_balance_limit, \"too much deposit\");\n\n        // Actual transfer.\n        require(token.transferFrom(msg.sender, address(this), added_deposit), \"tokens didn't transfer\");\n    }\n\n    /// @notice Internally transfer deposits between two addresses.\n    /// Sender and receiver must be different or the transaction will fail.\n    /// @param sender Account from which the amount will be deducted\n    /// @param receiver Account to which the amount will be credited\n    /// @param amount Amount of tokens to be transferred\n    /// @return success true if transfer has been done successfully, otherwise false\n    function transfer(\n        address sender,\n        address receiver,\n        uint256 amount\n    )\n        external\n        canTransfer()\n        returns (bool success)\n    {\n        require(sender != receiver, \"sender == receiver\");\n        if (balances[sender] >= amount && amount > 0) {\n            balances[sender] -= amount;\n            balances[receiver] += amount;\n            emit BalanceReduced(sender, balances[sender]);\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /// @notice Announce intention to withdraw tokens.\n    /// Sets the planned withdraw amount and resets the withdraw_block.\n    /// There is only one planned withdrawal at a time, the old one gets overwritten.\n    /// @param amount Maximum amount of tokens to be withdrawn\n    function planWithdraw(uint256 amount)\n        external\n    {\n        require(amount > 0, \"withdrawing zero\");\n        require(balances[msg.sender] >= amount, \"withdrawing too much\");\n\n        withdraw_plans[msg.sender] = WithdrawPlan({\n            amount: amount,\n            withdraw_block: block.number + withdraw_delay\n        });\n        emit WithdrawPlanned(msg.sender, balances[msg.sender] - amount);\n    }\n\n    /// @notice Execute a planned withdrawal\n    /// Will only work after the withdraw_delay has expired.\n    /// An amount lower or equal to the planned amount may be withdrawn.\n    /// Removes the withdraw plan even if not the full amount has been\n    /// withdrawn.\n    /// @param amount Amount of tokens to be withdrawn\n    function withdraw(uint256 amount)\n        external\n    {\n        WithdrawPlan storage withdraw_plan = withdraw_plans[msg.sender];\n        require(amount <= withdraw_plan.amount, \"withdrawing more than planned\");\n        require(withdraw_plan.withdraw_block <= block.number, \"withdrawing too early\");\n        uint256 withdrawable = min(amount, balances[msg.sender]);\n        balances[msg.sender] -= withdrawable;\n\n        // Update whole_balance, but take care against underflows.\n        require(whole_balance - withdrawable <= whole_balance, \"underflow in whole_balance\");\n        whole_balance -= withdrawable;\n\n        emit BalanceReduced(msg.sender, balances[msg.sender]);\n        delete withdraw_plans[msg.sender];\n\n        require(token.transfer(msg.sender, withdrawable), \"tokens didn't transfer\");\n    }\n\n    /// @notice The owner's balance with planned withdrawals deducted\n    /// @param owner Address for which the balance should be returned\n    /// @return remaining_balance The remaining balance after planned withdrawals\n    function effectiveBalance(address owner)\n        external\n        view\n        returns (uint256 remaining_balance)\n    {\n        WithdrawPlan storage withdraw_plan = withdraw_plans[owner];\n        if (withdraw_plan.amount > balances[owner]) {\n            return 0;\n        }\n        return balances[owner] - withdraw_plan.amount;\n    }\n\n    function min(uint256 a, uint256 b) internal pure returns (uint256)\n    {\n        return a > b ? b : a;\n    }\n}\n\n\n// MIT License\n\n// Copyright (c) 2018\n\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n\n// The above copyright notice and this permission notice shall be included in all\n// copies or substantial portions of the Software.\n\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n// SOFTWARE."
    },
    "data/source/raiden/Token.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity 0.7.6;\r\n\r\ninterface Token {\r\n\r\n    /// @return supply total amount of tokens\r\n    function totalSupply() external view returns (uint256 supply);\r\n\r\n    /// @param _owner The address from which the balance will be retrieved\r\n    /// @return balance The balance\r\n    function balanceOf(address _owner) external view returns (uint256 balance);\r\n\r\n    /// @notice send `_value` token to `_to` from `msg.sender`\r\n    /// @param _to The address of the recipient\r\n    /// @param _value The amount of token to be transferred\r\n    /// @return success Whether the transfer was successful or not\r\n    function transfer(address _to, uint256 _value) external returns (bool success);\r\n\r\n    /// @notice send `_value` token to `_to` from `_from` on the condition it is approved by `_from`\r\n    /// @param _from The address of the sender\r\n    /// @param _to The address of the recipient\r\n    /// @param _value The amount of token to be transferred\r\n    /// @return success Whether the transfer was successful or not\r\n    function transferFrom(address _from, address _to, uint256 _value) external returns (bool success);\r\n\r\n    /// @notice `msg.sender` approves `_spender` to spend `_value` tokens\r\n    /// @param _spender The address of the account able to transfer the tokens\r\n    /// @param _value The amount of wei to be approved for transfer\r\n    /// @return success Whether the approval was successful or not\r\n    function approve(address _spender, uint256 _value) external returns (bool success);\r\n\r\n    /// @param _owner The address of the account owning tokens\r\n    /// @param _spender The address of the account able to transfer the tokens\r\n    /// @return remaining Amount of remaining tokens allowed to spent\r\n    function allowance(address _owner, address _spender) external view returns (uint256 remaining);\r\n\r\n    event Transfer(address indexed _from, address indexed _to, uint256 _value);\r\n    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\r\n\r\n    // Optionally implemented function to show the number of decimals for the token\r\n    function decimals() external view returns (uint8 decimals);\r\n}\r\n"
    },
    "data/source/test/StandardToken.sol": {
      "content": "// SPDX-License-Identifier: MIT\n/* solium-disable */\npragma solidity 0.7.6;\n\nimport \"../raiden/Token.sol\";\n\n/*\nThis implements ONLY the standard functions and NOTHING else.\nFor a token like you would want to deploy in something like Mist, see HumanStandardToken.sol.\nIf you deploy this, you won't have anything useful.\nImplements ERC 20 Token standard: https://github.com/ethereum/EIPs/issues/20\n.*/\n\ncontract StandardToken is Token {\n    uint256 internal _total_supply;\n    mapping (address => uint256) public balances;\n    mapping (address => mapping (address => uint256)) allowed;\n\n    function transfer(address _to, uint256 _value)\n        public override\n        returns (bool success)\n    {\n        //Default assumes totalSupply can't be over max (2^256 - 1).\n        //If your token leaves out totalSupply and can issue more tokens as time goes on, you need to check if it doesn't wrap.\n        //Replace the if with this one instead.\n        //if (balances[msg.sender] >= _value && balances[_to] + _value > balances[_to]) {\n        if (balances[msg.sender] >= _value && _value > 0) {\n            balances[msg.sender] -= _value;\n            balances[_to] += _value;\n            emit Transfer(msg.sender, _to, _value);\n            return true;\n        } else { return false; }\n    }\n\n    function transferFrom(address _from, address _to, uint256 _value)\n        public override\n        returns (bool success)\n    {\n        //same as above. Replace this line with the following if you want to protect against wrapping uints.\n        //if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && balances[_to] + _value > balances[_to]) {\n        require(balances[_from] >= _value);\n        require(allowed[_from][msg.sender] >= _value);\n        require(_value > 0);\n        if ((balances[_from] >= _value) && (allowed[_from][msg.sender] >= _value) && (_value > 0)) {\n            balances[_to] += _value;\n            balances[_from] -= _value;\n            allowed[_from][msg.sender] -= _value;\n            emit Transfer(_from, _to, _value);\n            return true;\n        } else { return false; }\n    }\n\n    function balanceOf(address _owner) public override view returns (uint256 balance) {\n        return balances[_owner];\n    }\n\n    function approve(address _spender, uint256 _value) public override returns (bool success) {\n        allowed[msg.sender][_spender] = _value;\n        emit Approval(msg.sender, _spender, _value);\n        return true;\n    }\n\n    function allowance(address _owner, address _spender) public override view returns (uint256 remaining) {\n      return allowed[_owner][_spender];\n    }\n\n    function totalSupply() public override view returns (uint256 supply) {\n        return _total_supply;\n    }\n\n    function decimals() public virtual override view returns (uint8 decimals) {\n        return 18;\n    }\n}"
    },
    "data/source/test/CustomToken.sol": {
      "content": "// SPDX-License-Identifier: MIT\n/* solium-disable error-reason */\npragma solidity 0.7.6;\n\n/*\nThis Token Contract implements the standard token functionality (https://github.com/ethereum/EIPs/issues/20), the ERC223 functionality (https://github.com/ethereum/EIPs/issues/223) as well as the following OPTIONAL extras intended for use by humans.\nIn other words. This is intended for deployment in something like a Token Factory or Mist wallet, and then used by humans.\nImagine coins, currencies, shares, voting weight, etc.\nMachine-based, rapid creation of many tokens would not necessarily need these extra features or will be minted in other manners.\n1) Initial Finite Supply (upon creation one specifies how much is minted).\n2) In the absence of a token registry: Optional Decimal, Symbol & Name.\n.*/\n\nimport \"./StandardToken.sol\";\n\n/// @title CustomToken\ncontract CustomToken is StandardToken {\n\n    /*\n     *  Token metadata\n     */\n    string public version = \"H0.1\";       //human 0.1 standard. Just an arbitrary versioning scheme.\n    string public name;\n    string public symbol;\n    uint8 public _decimals;\n    uint256 public multiplier;\n\n    address payable public owner_address;\n\n    /*\n     * Events\n     */\n    event Minted(address indexed _to, uint256 indexed _num);\n\n    /*\n     *  Public functions\n     */\n    /// @dev Contract constructor function.\n    /// @param initial_supply Initial supply of tokens\n    /// @param decimal_units Number of token decimals\n    /// @param token_name Token name for display\n    /// @param token_symbol Token symbol\n    constructor(\n        uint256 initial_supply,\n        uint8 decimal_units,\n        string memory token_name,\n        string memory token_symbol\n    ) {\n        // Set the name for display purposes\n        name = token_name;\n\n        // Amount of decimals for display purposes\n        _decimals = decimal_units;\n        multiplier = 10**(uint256(decimal_units));\n\n        // Set the symbol for display purposes\n        symbol = token_symbol;\n\n        // Initial supply is assigned to the owner\n        owner_address = msg.sender;\n        balances[owner_address] = initial_supply;\n        _total_supply = initial_supply;\n    }\n\n    /// @notice Allows `num` tokens to be minted and assigned to `msg.sender`\n    function mint(uint256 num) public {\n        mintFor(num, msg.sender);\n    }\n\n    /// @notice Allows `num` tokens to be minted and assigned to `target`\n    function mintFor(uint256 num, address target) public {\n        balances[target] += num;\n        _total_supply += num;\n\n        emit Minted(target, num);\n\n        require(balances[target] >= num);\n        assert(_total_supply >= num);\n    }\n\n    /// @notice Transfers the collected ETH to the contract owner.\n    /// @notice OVM does not support the use of address(this).balance due to\n    /// a lack of native ETH, WETH should be used instead.\n    /*function transferFunds() public {\n        require(msg.sender == owner_address);\n        require(address(this).balance > 0);\n\n        owner_address.transfer(address(this).balance);\n        assert(address(this).balance == 0);\n    }*/\n\n    function decimals() public override view returns (uint8 decimals) {\n        return _decimals;\n    }\n}"
    },
    "data/source/services/MonitoringService.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.7.6;\n\nimport \"../lib/ECVerify.sol\";\nimport \"../lib/MessageType.sol\";\nimport \"../raiden/Token.sol\";\nimport \"../raiden/Utils.sol\";\nimport \"../raiden/TokenNetwork.sol\";\nimport \"../raiden/TokenNetworkRegistry.sol\";\nimport \"./ServiceRegistry.sol\";\nimport \"./UserDeposit.sol\";\n\ncontract MonitoringService is Utils {\n    // Token to be used for paying the rewards\n    Token public token;\n\n    // Raiden Service Bundle contract to use for checking if MS has deposits\n    ServiceRegistry public service_registry;\n    UserDeposit public user_deposit;\n    TokenNetworkRegistry public token_network_registry;\n\n    // keccak256(channel_identifier, token_network_address) => Struct\n    // Keep track of the rewards per channel\n    mapping(bytes32 => Reward) internal rewards;\n\n    /*\n     *  Structs\n     */\n    struct Reward{\n        // The amount of tokens to be rewarded\n        uint256 reward_amount;\n\n        // Nonce of the most recently provided BP\n        uint256 nonce;\n\n        // Address of the Raiden Node that was monitored\n        // This is also the address that has the reward deducted from its deposit\n        address reward_sender_address;\n\n        // Address of the Monitoring Service who is currently eligible to claim the reward\n        address monitoring_service_address;\n    }\n\n    /*\n     *  Events\n     */\n\n    event NewBalanceProofReceived(\n        address token_network_address,\n        uint256 channel_identifier,\n        uint256 reward_amount,\n        uint256 indexed nonce,\n        address indexed ms_address,\n        address indexed raiden_node_address\n    );\n    event RewardClaimed(address indexed ms_address, uint amount, bytes32 indexed reward_identifier);\n\n    /*\n     *  Constructor\n     */\n\n    /// @notice Set the default values for the smart contract\n    /// @param _token_address The address of the token to use for rewards\n    /// @param _service_registry_address The address of the ServiceRegistry contract\n    /// @param _token_network_registry_address The address of the TokenNetworkRegistry for authenticating TokenNetworks\n    constructor(\n        address _token_address,\n        address _service_registry_address,\n        address _udc_address,\n        address _token_network_registry_address\n    ) {\n        require(_token_address != address(0x0), \"Token at address zero\");\n        require(_service_registry_address != address(0x0), \"ServiceRegistry at address zero\");\n        require(_udc_address != address(0x0), \"UDC at address zero\");\n        require(contractExists(_token_address), \"token has no code\");\n        require(contractExists(_service_registry_address), \"ServiceRegistry has no code\");\n        require(contractExists(_udc_address), \"UDC has no code\");\n        require(contractExists(_token_network_registry_address), \"TokenNetworkRegistry has no code\");\n\n        token = Token(_token_address);\n        service_registry = ServiceRegistry(_service_registry_address);\n        user_deposit = UserDeposit(_udc_address);\n        token_network_registry = TokenNetworkRegistry(_token_network_registry_address);\n        // Check if the contract is indeed a token contract\n        require(token.totalSupply() > 0, \"Token with zero total supply\");\n        // Check if the contract is indeed a service_registry contract\n        // TODO: Check that some function exists in the contract\n    }\n\n    /// @notice Internal function that updates the Reward struct if a newer balance proof\n    /// is provided in the monitor() function\n    /// @param token_network_address Address of the TokenNetwork being monitored\n    /// @param closing_participant The address of the participant who closed the channel\n    /// @param non_closing_participant Address of the other channel participant. This is\n    /// the participant on whose behalf the MS acts.\n    /// @param reward_amount The amount of tokens to be rewarded\n    /// @param nonce The nonce of the newly provided balance_proof\n    /// @param monitoring_service_address The address of the MS calling monitor()\n    /// @param non_closing_signature Non-closing participant signature of the\n    /// balance proof data.\n    /// @param reward_proof_signature The signature of the signed reward proof\n    function updateReward(\n        address token_network_address,\n        address closing_participant,\n        address non_closing_participant,\n        uint256 reward_amount,\n        uint256 nonce,\n        address monitoring_service_address,\n        bytes memory non_closing_signature,\n        bytes memory reward_proof_signature\n    )\n        internal\n    {\n        TokenNetwork token_network = TokenNetwork(token_network_address);\n        address token_network_token = address(token_network.token());\n        require(\n            token_network_registry.token_to_token_networks(token_network_token) ==\n            address(token_network),\n            \"Unknown TokenNetwork\"\n        );\n        uint256 channel_identifier = token_network.getChannelIdentifier(\n            closing_participant, non_closing_participant\n        );\n\n        // Make sure that the reward proof is signed by the non_closing_participant\n        address raiden_node_address = recoverAddressFromRewardProof(\n            token_network.chain_id(),\n            token_network_address,\n            non_closing_participant,\n            non_closing_signature,\n            reward_amount,\n            reward_proof_signature\n        );\n        require(raiden_node_address == non_closing_participant, \"Bad reward proof\");\n\n        bytes32 reward_identifier = keccak256(\n            abi.encodePacked(\n                channel_identifier,\n                token_network_address\n            )\n        );\n\n        // Get the Reward struct for the correct channel\n        Reward storage reward = rewards[reward_identifier];\n\n        // Only allow BPs with higher nonce to be submitted\n        require(reward.nonce < nonce, \"stale nonce\");\n\n        // MSC stores channel_identifier, MS_address, reward_amount, nonce\n        // of the MS that provided the balance_proof with highest nonce\n        rewards[reward_identifier] = Reward({\n            reward_amount: reward_amount,\n            nonce: nonce,\n            reward_sender_address: non_closing_participant,\n            monitoring_service_address: monitoring_service_address\n        });\n    }\n\n    /// @notice Called by a registered MS, when providing a new balance proof\n    /// to a monitored channel.\n    /// Can be called multiple times by different registered MSs as long as the BP provided\n    /// is newer than the current newest registered BP.\n    /// @param nonce Strictly monotonic value used to order BPs\n    /// omitting PB specific params, since these will not be provided in the future\n    /// @param reward_amount Amount of tokens to be rewarded\n    /// @param token_network_address Address of the Token Network in which the channel\n    /// being monitored exists.\n    /// @param reward_proof_signature The signature of the signed reward proof\n    function monitor(\n        address closing_participant,\n        address non_closing_participant,\n        bytes32 balance_hash,\n        uint256 nonce,\n        bytes32 additional_hash,\n        bytes memory closing_signature,\n        bytes memory non_closing_signature,\n        uint256 reward_amount,\n        address token_network_address,\n        bytes memory reward_proof_signature\n    )\n        public\n    {\n        // Here we're trying to do bookkeeping first, but updateReward() first calls\n        // token_network_address.  So reentrancy is possible.\n        // In that case, the outer frame fails and reverts the state\n        // because token_network_address is not registered in the token_network_registry.\n        //\n        // Maybe it's simpler and safer to take the token address as an argument instead,\n        // and ask the TokenNetworkRegistry for the token_network_address.\n        updateReward(\n            token_network_address,\n            closing_participant,\n            non_closing_participant,\n            reward_amount,\n            nonce,\n            msg.sender,\n            non_closing_signature,\n            reward_proof_signature\n        );\n\n        TokenNetwork token_network = TokenNetwork(token_network_address);\n        uint256 channel_identifier = token_network.getChannelIdentifier(\n            closing_participant, non_closing_participant\n        );\n        require(\n            block.number >= firstBlockAllowedToMonitorChannel(\n                token_network,\n                channel_identifier,\n                closing_participant,\n                non_closing_participant,\n                msg.sender\n            ),\n            \"not allowed to monitor\"\n        );\n\n        // Call updateTransfer in the corresponding TokenNetwork\n        token_network.updateNonClosingBalanceProof(\n            channel_identifier,\n            closing_participant,\n            non_closing_participant,\n            balance_hash,\n            nonce,\n            additional_hash,\n            closing_signature,\n            non_closing_signature\n        );\n\n        emit NewBalanceProofReceived(\n            token_network_address,\n            channel_identifier,\n            reward_amount,\n            nonce,\n            msg.sender,\n            non_closing_participant\n        );\n    }\n\n    function firstBlockAllowedToMonitorChannel(\n        TokenNetwork token_network,\n        uint256 channel_identifier,\n        address closing_participant,\n        address non_closing_participant,\n        address monitoring_service_address\n    )\n        public view\n        returns (uint256)\n    {\n        require(service_registry.hasValidRegistration(monitoring_service_address), \"service not registered\");\n\n        TokenNetwork.ChannelState channel_state;\n        uint256 settle_block_number;\n        (settle_block_number, channel_state) = token_network.getChannelInfo(\n            channel_identifier, closing_participant, non_closing_participant\n        );\n        require(channel_state == TokenNetwork.ChannelState.Closed, \"channel not closed\");\n\n        // We don't actually know when the channel has been closed. So we'll\n        // make a guess so that assumed_close_block >= real_close_block.\n        uint256 assumed_settle_timeout = token_network.settlement_timeout_min();\n        require(settle_block_number >= assumed_settle_timeout, \"too low settle block number\");\n        uint256 assumed_close_block = settle_block_number - assumed_settle_timeout;\n\n        return firstBlockAllowedToMonitor(\n            assumed_close_block,\n            assumed_settle_timeout,\n            closing_participant,\n            non_closing_participant,\n            monitoring_service_address\n        );\n    }\n\n    function firstBlockAllowedToMonitor(\n        uint256 closed_at_block,\n        uint256 settle_timeout,\n        address participant1,\n        address participant2,\n        address monitoring_service_address\n    )\n        public pure\n        returns (uint256)\n    {\n        // avoid overflows when multiplying with percentages\n        require(settle_timeout < uint256(2**256 - 1) / 100, \"maliciously big settle timeout\");\n        require(closed_at_block < uint256(2**256 - 1) / 100, \"maliciously big closed_at_block\");\n\n        // First allowed block as percentage of settle_timeout. We're using\n        // integers here to avoid accuracy loss during calculations.\n        uint256 BEST_CASE = 30;\n        uint256 WORST_CASE = 80;\n\n        // When is the first block that any MS might be allowed to monitor\n        uint256 best_case_block = closed_at_block + BEST_CASE * settle_timeout / 100;\n        // Length of the range into which the first allowed block will fall\n        uint256 range_length = (WORST_CASE - BEST_CASE) * settle_timeout / 100;\n\n        // Offset for this specific MS within the range\n        uint256 ms_offset = (\n            uint256(participant1) +\n            uint256(participant2) +\n            uint256(monitoring_service_address)\n        ) % range_length;\n\n        return best_case_block + ms_offset;\n    }\n\n    /// @notice Called after a monitored channel is settled in order for MS to claim the reward\n    /// Can be called once per settled channel by everyone on behalf of MS\n    /// @param token_network_address Address of the Token Network in which the channel exists\n    /// @param closing_participant Address of the participant of the channel that called close\n    /// @param non_closing_participant The other participant of the channel\n    function claimReward(\n        uint256 channel_identifier,\n        address token_network_address,\n        address closing_participant,\n        address non_closing_participant\n    )\n        public\n        returns (bool)\n    {\n        TokenNetwork token_network = TokenNetwork(token_network_address);\n        bytes32 reward_identifier = keccak256(\n            abi.encodePacked(\n                channel_identifier,\n                token_network_address\n            )\n        );\n\n        // Only allowed to claim, if channel is settled\n        // Channel is settled if it's data has been deleted\n        TokenNetwork.ChannelState channel_state;\n        uint256 settle_block_number;\n        (settle_block_number, channel_state) = token_network.getChannelInfo(\n            channel_identifier,\n            closing_participant,\n            non_closing_participant\n        );\n        // We are trying to figure out when the settlement period ends.\n        // The meaning of settle_block_number is totally different depending on channel_state.\n        // When channel_state is NonExistent, settle_block_number is zero so it's not useful.\n        // When channel_state is Open, settle_block_number is the length of the settlement period.\n        // In these cases, we don't want to proceed anyway because the settlement period has not even started.\n        // We can only proceed with these other channel states.\n        require(\n            channel_state == TokenNetwork.ChannelState.Closed ||\n            channel_state == TokenNetwork.ChannelState.Settled ||\n            channel_state == TokenNetwork.ChannelState.Removed, \"too early channel state\"\n        );\n        require(settle_block_number < block.number, \"channel not settled yet\");\n\n        Reward storage reward = rewards[reward_identifier];\n\n        // Make sure that the Reward exists\n        require(reward.reward_sender_address != address(0x0), \"reward_sender is zero\");\n\n        // Add reward to the monitoring service's balance\n        require(\n            user_deposit.transfer(\n                reward.reward_sender_address,\n                reward.monitoring_service_address,\n                reward.reward_amount\n            ),\n            \"UDC did not transfer\"\n        );\n\n        emit RewardClaimed(\n            reward.monitoring_service_address,\n            reward.reward_amount,\n            reward_identifier\n        );\n\n        // delete storage\n        delete rewards[reward_identifier];\n\n        return true;\n    }\n\n    function recoverAddressFromRewardProof(\n        uint256 chain_id,\n        address token_network_address,\n        address non_closing_participant,\n        bytes memory non_closing_signature,\n        uint256 reward_amount,\n        bytes memory signature\n    )\n        internal\n        view\n        returns (address signature_address)\n    {\n        // This message shows the intention of the signer to pay\n        // a reward to a Monitoring Service, provided that the\n        // call of updateNonClosingBalanceProof() succeeds.\n        // The triple (non_closing_participant, non_closing_signature, token_network_address)\n        // uniquely identifies the call that's supposed to be made.\n        // (Just checking non_closing_signature is not enough because\n        // when an attacker tampers with the payload, the signature\n        // verification doesn't fail but emits a different address.)\n        // (Without a token_network, there will be some ambiguity\n        // what the payload means.)\n        bytes32 message_hash = keccak256(\n            abi.encodePacked(\n                \"\\x19Ethereum Signed Message:\\n221\",  // 20 + 32 + 32 + 20 + 20 + 65 + 32\n                address(this),\n                chain_id,\n                uint256(MessageType.MessageTypeId.MSReward),\n                token_network_address,\n                non_closing_participant,\n                non_closing_signature,\n                reward_amount\n            )\n        );\n\n        signature_address = ECVerify.ecverify(message_hash, signature);\n        require(signature_address == non_closing_participant, \"Reward proof with wrong non_closing_participant\");\n    }\n}\n\n\n// MIT License\n\n// Copyright (c) 2018\n\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n\n// The above copyright notice and this permission notice shall be included in all\n// copies or substantial portions of the Software.\n\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n// SOFTWARE."
    },
    "data/source/raiden/TokenNetwork.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n/* solium-disable error-reason */\r\n/* solium-disable indentation */\r\npragma solidity 0.7.6;\r\npragma experimental ABIEncoderV2;\r\n\r\nimport \"../lib/ECVerify.sol\";\r\nimport \"../lib/MessageType.sol\";\r\nimport \"../lib/TokenNetworkUtils.sol\";\r\nimport \"./Token.sol\";\r\nimport \"./Utils.sol\";\r\nimport \"./SecretRegistry.sol\";\r\n\r\n/// @title TokenNetwork\r\n/// @notice Stores and manages all the Raiden Network channels that use the\r\n/// token specified in this TokenNetwork contract.\r\ncontract TokenNetwork is Utils {\r\n    // Instance of the token used by the channels\r\n    Token public token;\r\n\r\n    // Instance of SecretRegistry used for storing secrets revealed in a\r\n    // mediating transfer.\r\n    SecretRegistry public secret_registry;\r\n\r\n    // Chain ID as specified by EIP155 used in balance proof signatures to\r\n    // avoid replay attacks\r\n    uint256 public chain_id;\r\n\r\n    uint256 public settlement_timeout_min;\r\n    uint256 public settlement_timeout_max;\r\n\r\n    uint256 constant public MAX_SAFE_UINT256 = (\r\n        115792089237316195423570985008687907853269984665640564039457584007913129639935\r\n    );\r\n\r\n    // The deposit limit per channel per participant.\r\n    uint256 public channel_participant_deposit_limit;\r\n    // The total combined deposit of all channels across the whole network\r\n    uint256 public token_network_deposit_limit;\r\n\r\n    // Global, monotonically increasing counter that keeps track of all the\r\n    // opened channels in this contract\r\n    uint256 public channel_counter;\r\n\r\n    // Only for the limited Red Eyes release\r\n    address public deprecation_executor;\r\n    bool public safety_deprecation_switch = false;\r\n\r\n    // channel_identifier => Channel\r\n    // channel identifier is the channel_counter value at the time of opening\r\n    // the channel\r\n    mapping (uint256 => Channel) public channels;\r\n\r\n    // This is needed to enforce one channel per pair of participants\r\n    // The key is keccak256(participant1_address, participant2_address)\r\n    mapping (bytes32 => uint256) public participants_hash_to_channel_identifier;\r\n\r\n    // We keep the unlock data in a separate mapping to allow channel data\r\n    // structures to be removed when settling uncooperatively. If there are\r\n    // locked pending transfers, we need to store data needed to unlock them at\r\n    // a later time.\r\n    // The key is `keccak256(uint256 channel_identifier, address participant,\r\n    // address partner)` Where `participant` is the participant that sent the\r\n    // pending transfers We need `partner` for knowing where to send the\r\n    // claimable tokens\r\n    mapping(bytes32 => UnlockData) private unlock_identifier_to_unlock_data;\r\n\r\n    struct Participant {\r\n        // Total amount of tokens transferred to this smart contract through\r\n        // the `setTotalDeposit` function, for a specific channel, in the\r\n        // participant's benefit.\r\n        // This is a strictly monotonic value. Note that direct token transfer\r\n        // into the contract cannot be tracked and will be stuck.\r\n        uint256 deposit;\r\n\r\n        // Total amount of tokens withdrawn by the participant during the\r\n        // lifecycle of this channel.\r\n        // This is a strictly monotonic value.\r\n        uint256 withdrawn_amount;\r\n\r\n        // This is a value set to true after the channel has been closed, only\r\n        // if this is the participant who closed the channel.\r\n        bool is_the_closer;\r\n\r\n        // keccak256 of the balance data provided after a closeChannel or an\r\n        // updateNonClosingBalanceProof call\r\n        bytes32 balance_hash;\r\n\r\n        // Monotonically increasing counter of the off-chain transfers,\r\n        // provided along with the balance_hash\r\n        uint256 nonce;\r\n    }\r\n\r\n    enum ChannelState {\r\n        NonExistent, // 0\r\n        Opened,      // 1\r\n        Closed,      // 2\r\n        Settled,     // 3; Note: The channel has at least one pending unlock\r\n        Removed      // 4; Note: Channel data is removed, there are no pending unlocks\r\n    }\r\n\r\n    struct Channel {\r\n        // After opening the channel this value represents the settlement\r\n        // window. This is the number of blocks that need to be mined between\r\n        // closing the channel uncooperatively and settling the channel.\r\n        // After the channel has been uncooperatively closed, this value\r\n        // represents the block number after which settleChannel can be called.\r\n        uint256 settle_block_number;\r\n\r\n        ChannelState state;\r\n\r\n        mapping(address => Participant) participants;\r\n    }\r\n\r\n    struct SettlementData {\r\n        uint256 deposit;\r\n        uint256 withdrawn;\r\n        uint256 transferred;\r\n        uint256 locked;\r\n    }\r\n\r\n    struct UnlockData {\r\n        // keccak256 hash of the pending locks from the Raiden client\r\n        bytes32 locksroot;\r\n        // Total amount of tokens locked in the pending locks corresponding\r\n        // to the `locksroot`\r\n        uint256 locked_amount;\r\n    }\r\n\r\n    struct SettleInput {\r\n        address participant;\r\n        uint256 transferred_amount;\r\n        uint256 locked_amount;\r\n        bytes32 locksroot;\r\n    }\r\n\r\n    event ChannelOpened(\r\n        uint256 indexed channel_identifier,\r\n        address indexed participant1,\r\n        address indexed participant2,\r\n        uint256 settle_timeout\r\n    );\r\n\r\n    event ChannelNewDeposit(\r\n        uint256 indexed channel_identifier,\r\n        address indexed participant,\r\n        uint256 total_deposit\r\n    );\r\n\r\n    // Fires when the deprecation_switch's value changes\r\n    event DeprecationSwitch(bool new_value);\r\n\r\n    // total_withdraw is how much the participant has withdrawn during the\r\n    // lifetime of the channel. The actual amount which the participant withdrew\r\n    // is `total_withdraw - total_withdraw_from_previous_event_or_zero`\r\n    event ChannelWithdraw(\r\n        uint256 indexed channel_identifier,\r\n        address indexed participant,\r\n        uint256 total_withdraw\r\n    );\r\n\r\n    event ChannelClosed(\r\n        uint256 indexed channel_identifier,\r\n        address indexed closing_participant,\r\n        uint256 indexed nonce,\r\n        bytes32 balance_hash\r\n    );\r\n\r\n    event ChannelUnlocked(\r\n        uint256 indexed channel_identifier,\r\n        address indexed receiver,\r\n        address indexed sender,\r\n        bytes32 locksroot,\r\n        uint256 unlocked_amount,\r\n        uint256 returned_tokens\r\n    );\r\n\r\n    event NonClosingBalanceProofUpdated(\r\n        uint256 indexed channel_identifier,\r\n        address indexed closing_participant,\r\n        uint256 indexed nonce,\r\n        bytes32 balance_hash\r\n    );\r\n\r\n    event ChannelSettled(\r\n        uint256 indexed channel_identifier,\r\n        uint256 participant1_amount,\r\n        bytes32 participant1_locksroot,\r\n        uint256 participant2_amount,\r\n        bytes32 participant2_locksroot\r\n    );\r\n\r\n    modifier onlyDeprecationExecutor() {\r\n        require(msg.sender == deprecation_executor);\r\n        _;\r\n    }\r\n\r\n    modifier isSafe() {\r\n        require(safety_deprecation_switch == false);\r\n        _;\r\n    }\r\n\r\n    modifier isOpen(uint256 channel_identifier) {\r\n        require(channels[channel_identifier].state == ChannelState.Opened);\r\n        _;\r\n    }\r\n\r\n    modifier settleTimeoutValid(uint256 timeout) {\r\n        require(timeout >= settlement_timeout_min);\r\n        require(timeout <= settlement_timeout_max);\r\n        _;\r\n    }\r\n\r\n    /// @param _token_address The address of the ERC20 token contract\r\n    /// @param _secret_registry The address of SecretRegistry contract that witnesses the onchain secret reveals\r\n    /// @param _chain_id EIP-155 Chain ID of the blockchain where this instance is being deployed\r\n    /// @param _settlement_timeout_min The shortest settlement period (in number of blocks)\r\n    /// that can be chosen at the channel opening\r\n    /// @param _settlement_timeout_max The longest settlement period (in number of blocks)\r\n    /// that can be chosen at the channel opening\r\n    /// @param _deprecation_executor The Ethereum address that can disable new deposits and channel creation\r\n    /// @param _channel_participant_deposit_limit The maximum amount of tokens that can be deposited by each\r\n    /// participant of each channel. MAX_SAFE_UINT256 means no limits\r\n    /// @param _token_network_deposit_limit The maximum amount of tokens that this contract can hold\r\n    /// MAX_SAFE_UINT256 means no limits\r\n    constructor(\r\n        address _token_address,\r\n        address _secret_registry,\r\n        uint256 _chain_id,\r\n        uint256 _settlement_timeout_min,\r\n        uint256 _settlement_timeout_max,\r\n        address _deprecation_executor,\r\n        uint256 _channel_participant_deposit_limit,\r\n        uint256 _token_network_deposit_limit\r\n    ) {\r\n        require(_token_address != address(0x0));\r\n        require(_secret_registry != address(0x0));\r\n        require(_deprecation_executor != address(0x0));\r\n        require(_chain_id > 0);\r\n        require(_settlement_timeout_min > 0);\r\n        require(_settlement_timeout_max > _settlement_timeout_min);\r\n        require(contractExists(_token_address));\r\n        require(contractExists(_secret_registry));\r\n        require(_channel_participant_deposit_limit > 0);\r\n        require(_token_network_deposit_limit > 0);\r\n        require(_token_network_deposit_limit >= _channel_participant_deposit_limit);\r\n\r\n        token = Token(_token_address);\r\n\r\n        secret_registry = SecretRegistry(_secret_registry);\r\n        chain_id = _chain_id;\r\n        settlement_timeout_min = _settlement_timeout_min;\r\n        settlement_timeout_max = _settlement_timeout_max;\r\n\r\n        // Make sure the contract is indeed a token contract\r\n        require(token.totalSupply() > 0);\r\n\r\n        deprecation_executor = _deprecation_executor;\r\n        channel_participant_deposit_limit = _channel_participant_deposit_limit;\r\n        token_network_deposit_limit = _token_network_deposit_limit;\r\n    }\r\n\r\n    function deprecate() public isSafe onlyDeprecationExecutor {\r\n        safety_deprecation_switch = true;\r\n        emit DeprecationSwitch(safety_deprecation_switch);\r\n    }\r\n\r\n    /// @notice Opens a new channel between `participant1` and `participant2`.\r\n    /// Can be called by anyone\r\n    /// @param participant1 Ethereum address of a channel participant\r\n    /// @param participant2 Ethereum address of the other channel participant\r\n    /// @param settle_timeout Number of blocks that need to be mined between a\r\n    /// call to closeChannel and settleChannel\r\n    function openChannel(address participant1, address participant2, uint256 settle_timeout)\r\n        public\r\n        isSafe\r\n        settleTimeoutValid(settle_timeout)\r\n        returns (uint256)\r\n    {\r\n        bytes32 pair_hash;\r\n        uint256 channel_identifier;\r\n\r\n        // Red Eyes release token network limit\r\n        require(token.balanceOf(address(this)) < token_network_deposit_limit);\r\n\r\n        // First increment the counter\r\n        // There will never be a channel with channel_identifier == 0\r\n        channel_counter += 1;\r\n        channel_identifier = channel_counter;\r\n\r\n        pair_hash = getParticipantsHash(participant1, participant2);\r\n\r\n        // There must only be one channel opened between two participants at\r\n        // any moment in time.\r\n        require(participants_hash_to_channel_identifier[pair_hash] == 0);\r\n        participants_hash_to_channel_identifier[pair_hash] = channel_identifier;\r\n\r\n        Channel storage channel = channels[channel_identifier];\r\n\r\n        // We always increase the channel counter, therefore no channel data can already exist,\r\n        // corresponding to this channel_identifier. This check must never fail.\r\n        assert(channel.settle_block_number == 0);\r\n        assert(channel.state == ChannelState.NonExistent);\r\n\r\n        // Store channel information\r\n        channel.settle_block_number = settle_timeout;\r\n        channel.state = ChannelState.Opened;\r\n\r\n        emit ChannelOpened(\r\n            channel_identifier,\r\n            participant1,\r\n            participant2,\r\n            settle_timeout\r\n        );\r\n\r\n        return channel_identifier;\r\n    }\r\n\r\n    /// @notice Sets the channel participant total deposit value.\r\n    /// Can be called by anyone.\r\n    /// @param channel_identifier Identifier for the channel on which this\r\n    /// operation takes place\r\n    /// @param participant Channel participant whose deposit is being set\r\n    /// @param total_deposit The total amount of tokens that the participant\r\n    /// will have as a deposit\r\n    /// @param partner Channel partner address, needed to compute the total\r\n    /// channel deposit\r\n    function setTotalDeposit(\r\n        uint256 channel_identifier,\r\n        address participant,\r\n        uint256 total_deposit,\r\n        address partner\r\n    )\r\n        public\r\n        isSafe\r\n        isOpen(channel_identifier)\r\n    {\r\n        require(channel_identifier == getChannelIdentifier(participant, partner));\r\n        require(total_deposit > 0);\r\n        require(total_deposit <= channel_participant_deposit_limit);\r\n\r\n        uint256 added_deposit;\r\n        uint256 channel_deposit;\r\n\r\n        Channel storage channel = channels[channel_identifier];\r\n        Participant storage participant_state = channel.participants[participant];\r\n        Participant storage partner_state = channel.participants[partner];\r\n\r\n        // Calculate the actual amount of tokens that will be transferred\r\n        added_deposit = total_deposit - participant_state.deposit;\r\n\r\n        // The actual amount of tokens that will be transferred must be > 0\r\n        require(added_deposit > 0);\r\n\r\n        // Underflow check; we use <= because added_deposit == total_deposit for the first deposit\r\n\r\n        require(added_deposit <= total_deposit);\r\n\r\n        // This should never fail at this point. Added check for security, because we directly set\r\n        // the participant_state.deposit = total_deposit, while we transfer `added_deposit` tokens\r\n        assert(participant_state.deposit + added_deposit == total_deposit);\r\n\r\n        // Red Eyes release token network limit\r\n        require(token.balanceOf(address(this)) + added_deposit <= token_network_deposit_limit);\r\n\r\n        // Update the participant's channel deposit\r\n        participant_state.deposit = total_deposit;\r\n\r\n        // Calculate the entire channel deposit, to avoid overflow\r\n        channel_deposit = participant_state.deposit + partner_state.deposit;\r\n        // Overflow check\r\n        require(channel_deposit >= participant_state.deposit);\r\n\r\n        emit ChannelNewDeposit(\r\n            channel_identifier,\r\n            participant,\r\n            participant_state.deposit\r\n        );\r\n\r\n        // Do the transfer\r\n        require(token.transferFrom(msg.sender, address(this), added_deposit));\r\n    }\r\n\r\n    /// @notice Allows `participant` to withdraw tokens from the channel that he\r\n    /// has with `partner`, without closing it. Can be called by anyone. Can\r\n    /// only be called once per each signed withdraw message\r\n    /// @param channel_identifier Identifier for the channel on which this\r\n    /// operation takes place\r\n    /// @param participant Channel participant, who will receive the withdrawn\r\n    /// amount\r\n    /// @param total_withdraw Total amount of tokens that are marked as\r\n    /// withdrawn from the channel during the channel lifecycle\r\n    /// @param participant_signature Participant's signature on the withdraw\r\n    /// data\r\n    /// @param partner_signature Partner's signature on the withdraw data\r\n    function setTotalWithdraw(\r\n        uint256 channel_identifier,\r\n        address participant,\r\n        uint256 total_withdraw,\r\n        uint256 expiration_block,\r\n        bytes calldata participant_signature,\r\n        bytes calldata partner_signature\r\n    )\r\n        external\r\n        isOpen(channel_identifier)\r\n    {\r\n        uint256 total_deposit;\r\n        uint256 current_withdraw;\r\n        address partner;\r\n\r\n        require(total_withdraw > 0);\r\n        require(block.number < expiration_block);\r\n\r\n        // Authenticate both channel partners via their signatures.\r\n        // `participant` is a part of the signed message, so given in the calldata.\r\n        require(participant == TokenNetworkUtils.recoverAddressFromWithdrawMessage(\r\n            chain_id,\r\n            channel_identifier,\r\n            participant,\r\n            total_withdraw,\r\n            expiration_block,\r\n            participant_signature\r\n        ));\r\n        partner = TokenNetworkUtils.recoverAddressFromWithdrawMessage(\r\n            chain_id,\r\n            channel_identifier,\r\n            participant,\r\n            total_withdraw,\r\n            expiration_block,\r\n            partner_signature\r\n        );\r\n\r\n        // Validate that authenticated partners and the channel identifier match\r\n        require(channel_identifier == getChannelIdentifier(participant, partner));\r\n\r\n        // Read channel state after validating the function input\r\n        Channel storage channel = channels[channel_identifier];\r\n        Participant storage participant_state = channel.participants[participant];\r\n        Participant storage partner_state = channel.participants[partner];\r\n\r\n        total_deposit = participant_state.deposit + partner_state.deposit;\r\n\r\n        // Entire withdrawn amount must not be bigger than the current channel deposit\r\n        require((total_withdraw + partner_state.withdrawn_amount) <= total_deposit);\r\n        require(total_withdraw <= (total_withdraw + partner_state.withdrawn_amount));\r\n\r\n        // Using the total_withdraw (monotonically increasing) in the signed\r\n        // message ensures that we do not allow replay attack to happen, by\r\n        // using the same withdraw proof twice.\r\n        // Next two lines enforce the monotonicity of total_withdraw and check for an underflow:\r\n        // (we use <= because current_withdraw == total_withdraw for the first withdraw)\r\n        current_withdraw = total_withdraw - participant_state.withdrawn_amount;\r\n        require(current_withdraw <= total_withdraw);\r\n\r\n        // The actual amount of tokens that will be transferred must be > 0 to disable the reuse of\r\n        // withdraw messages completely.\r\n        require(current_withdraw > 0);\r\n\r\n        // This should never fail at this point. Added check for security, because we directly set\r\n        // the participant_state.withdrawn_amount = total_withdraw,\r\n        // while we transfer `current_withdraw` tokens.\r\n        assert(participant_state.withdrawn_amount + current_withdraw == total_withdraw);\r\n\r\n        emit ChannelWithdraw(\r\n            channel_identifier,\r\n            participant,\r\n            total_withdraw\r\n        );\r\n\r\n        // Do the state change and tokens transfer\r\n        participant_state.withdrawn_amount = total_withdraw;\r\n        require(token.transfer(participant, current_withdraw));\r\n\r\n        // This should never happen, as we have an overflow check in setTotalDeposit\r\n        assert(total_deposit >= participant_state.deposit);\r\n        assert(total_deposit >= partner_state.deposit);\r\n\r\n        // A withdraw should never happen if a participant already has a\r\n        // balance proof in storage. This should never fail as we use isOpen.\r\n        assert(participant_state.nonce == 0);\r\n        assert(partner_state.nonce == 0);\r\n\r\n    }\r\n\r\n    /// @notice Close the channel defined by the two participant addresses.\r\n    /// Anybody can call this function on behalf of a participant (called\r\n    /// the closing participant), providing a balance proof signed by\r\n    /// both parties. Callable only once\r\n    /// @param channel_identifier Identifier for the channel on which this\r\n    /// operation takes place\r\n    /// @param closing_participant Channel participant who closes the channel\r\n    /// @param non_closing_participant Channel partner of the `closing_participant`,\r\n    /// who provided the balance proof\r\n    /// @param balance_hash Hash of (transferred_amount, locked_amount,\r\n    /// locksroot)\r\n    /// @param additional_hash Computed from the message. Used for message\r\n    /// authentication\r\n    /// @param nonce Strictly monotonic value used to order transfers\r\n    /// @param non_closing_signature Non-closing participant's signature of the balance proof data\r\n    /// @param closing_signature Closing participant's signature of the balance\r\n    /// proof data\r\n    function closeChannel(\r\n        uint256 channel_identifier,\r\n        address non_closing_participant,\r\n        address closing_participant,\r\n        // The next four arguments form a balance proof.\r\n        bytes32 balance_hash,\r\n        uint256 nonce,\r\n        bytes32 additional_hash,\r\n        bytes memory non_closing_signature,\r\n        bytes memory closing_signature\r\n    )\r\n        public\r\n        isOpen(channel_identifier)\r\n    {\r\n        require(channel_identifier == getChannelIdentifier(closing_participant, non_closing_participant));\r\n\r\n        address recovered_non_closing_participant_address;\r\n\r\n        Channel storage channel = channels[channel_identifier];\r\n\r\n        channel.state = ChannelState.Closed;\r\n        channel.participants[closing_participant].is_the_closer = true;\r\n\r\n        // This is the block number at which the channel can be settled.\r\n        channel.settle_block_number += uint256(block.number);\r\n\r\n        // The closing participant must have signed the balance proof.\r\n        address recovered_closing_participant_address = TokenNetworkUtils.recoverAddressFromBalanceProofCounterSignature(\r\n            MessageType.MessageTypeId.BalanceProof,\r\n            chain_id,\r\n            channel_identifier,\r\n            balance_hash,\r\n            nonce,\r\n            additional_hash,\r\n            non_closing_signature,\r\n            closing_signature\r\n        );\r\n        require(closing_participant == recovered_closing_participant_address);\r\n\r\n        // Nonce 0 means that the closer never received a transfer, therefore\r\n        // never received a balance proof, or he is intentionally not providing\r\n        // the latest transfer, in which case the closing party is going to\r\n        // lose the tokens that were transferred to him.\r\n        if (nonce > 0) {\r\n            recovered_non_closing_participant_address = TokenNetworkUtils.recoverAddressFromBalanceProof(\r\n                chain_id,\r\n                channel_identifier,\r\n                balance_hash,\r\n                nonce,\r\n                additional_hash,\r\n                non_closing_signature\r\n            );\r\n            // Signature must be from the channel partner\r\n            require(non_closing_participant == recovered_non_closing_participant_address);\r\n\r\n            updateBalanceProofData(\r\n                channel,\r\n                recovered_non_closing_participant_address,\r\n                nonce,\r\n                balance_hash\r\n            );\r\n        }\r\n\r\n        emit ChannelClosed(channel_identifier, closing_participant, nonce, balance_hash);\r\n    }\r\n\r\n    /// @notice Called on a closed channel, the function allows the non-closing\r\n    /// participant to provide the last balance proof, which modifies the\r\n    /// closing participant's state. Can be called multiple times by anyone.\r\n    /// @param channel_identifier Identifier for the channel on which this\r\n    /// operation takes place\r\n    /// @param closing_participant Channel participant who closed the channel\r\n    /// @param non_closing_participant Channel participant who needs to update\r\n    /// the balance proof\r\n    /// @param balance_hash Hash of (transferred_amount, locked_amount,\r\n    /// locksroot)\r\n    /// @param additional_hash Computed from the message. Used for message\r\n    /// authentication\r\n    /// @param nonce Strictly monotonic value used to order transfers\r\n    /// @param closing_signature Closing participant's signature of the balance\r\n    /// proof data\r\n    /// @param non_closing_signature Non-closing participant signature of the\r\n    /// balance proof data\r\n    function updateNonClosingBalanceProof(\r\n        uint256 channel_identifier,\r\n        address closing_participant,\r\n        address non_closing_participant,\r\n        // The next four arguments form a balance proof\r\n        bytes32 balance_hash,\r\n        uint256 nonce,\r\n        bytes32 additional_hash,\r\n        bytes calldata closing_signature,\r\n        bytes calldata non_closing_signature\r\n    )\r\n        external\r\n    {\r\n        require(channel_identifier == getChannelIdentifier(\r\n            closing_participant,\r\n            non_closing_participant\r\n        ));\r\n        require(balance_hash != bytes32(0x0));\r\n        require(nonce > 0);\r\n\r\n        address recovered_non_closing_participant;\r\n        address recovered_closing_participant;\r\n\r\n        Channel storage channel = channels[channel_identifier];\r\n\r\n        require(channel.state == ChannelState.Closed);\r\n\r\n        // Calling this function after the settlement window is forbidden to\r\n        // fix the following race condition:\r\n        //\r\n        // 1 A badly configured node A, that doesn't have a monitoring service\r\n        //   and is temporarily offline does not call update during the\r\n        //   settlement window.\r\n        // 2 The well behaved partner B, who called close, sees the\r\n        //   settlement window is over and calls settle. At this point the B's\r\n        //   balance proofs which should be provided by A is missing, so B will\r\n        //   call settle with its balance proof zeroed out.\r\n        // 3 A restarts and calls update, which will change B's balance\r\n        //   proof.\r\n        // 4 At this point, the transactions from 2 and 3 are racing, and one\r\n        //   of them will fail.\r\n        //\r\n        // To avoid the above race condition, which would require special\r\n        // handling on both nodes, the call to update is forbidden after the\r\n        // settlement window. This does not affect safety, since we assume the\r\n        // nodes are always properly configured and have a monitoring service\r\n        // available to call update on the user's behalf.\r\n        require(channel.settle_block_number >= block.number);\r\n\r\n        // We need the signature from the non-closing participant to allow\r\n        // anyone to make this transaction. E.g. a monitoring service.\r\n        recovered_non_closing_participant = TokenNetworkUtils.recoverAddressFromBalanceProofCounterSignature(\r\n            MessageType.MessageTypeId.BalanceProofUpdate,\r\n            chain_id,\r\n            channel_identifier,\r\n            balance_hash,\r\n            nonce,\r\n            additional_hash,\r\n            closing_signature,\r\n            non_closing_signature\r\n        );\r\n        require(non_closing_participant == recovered_non_closing_participant);\r\n\r\n        recovered_closing_participant = TokenNetworkUtils.recoverAddressFromBalanceProof(\r\n            chain_id,\r\n            channel_identifier,\r\n            balance_hash,\r\n            nonce,\r\n            additional_hash,\r\n            closing_signature\r\n        );\r\n        require(closing_participant == recovered_closing_participant);\r\n\r\n        Participant storage closing_participant_state = channel.participants[closing_participant];\r\n        // Make sure the first signature is from the closing participant\r\n        require(closing_participant_state.is_the_closer);\r\n\r\n        // Update the balance proof data for the closing_participant\r\n        updateBalanceProofData(channel, closing_participant, nonce, balance_hash);\r\n\r\n        emit NonClosingBalanceProofUpdated(\r\n            channel_identifier,\r\n            closing_participant,\r\n            nonce,\r\n            balance_hash\r\n        );\r\n    }\r\n\r\n    /// @notice Settles the balance between the two parties. Note that arguments\r\n    /// order counts: `participant1_transferred_amount +\r\n    /// participant1_locked_amount` <= `participant2_transferred_amount +\r\n    /// participant2_locked_amount`\r\n    /// @param channel_identifier Identifier for the channel on which this\r\n    /// operation takes place\r\n    /// @param participant1 Channel participant\r\n    /// @param participant1_transferred_amount The latest known amount of tokens\r\n    /// transferred from `participant1` to `participant2`\r\n    /// @param participant1_locked_amount Amount of tokens owed by\r\n    /// `participant1` to `participant2`, contained in locked transfers that\r\n    /// will be retrieved by calling `unlock` after the channel is settled\r\n    /// @param participant1_locksroot The latest known hash of the\r\n    /// pending hash-time locks of `participant1`, used to validate the unlocked\r\n    /// proofs. If no balance_hash has been submitted, locksroot is ignored\r\n    /// @param participant2 Other channel participant\r\n    /// @param participant2_transferred_amount The latest known amount of tokens\r\n    /// transferred from `participant2` to `participant1`\r\n    /// @param participant2_locked_amount Amount of tokens owed by\r\n    /// `participant2` to `participant1`, contained in locked transfers that\r\n    /// will be retrieved by calling `unlock` after the channel is settled\r\n    /// @param participant2_locksroot The latest known hash of the\r\n    /// pending hash-time locks of `participant2`, used to validate the unlocked\r\n    /// proofs. If no balance_hash has been submitted, locksroot is ignored\r\n    function settleChannel(\r\n        uint256 channel_identifier,\r\n        address participant1,\r\n        uint256 participant1_transferred_amount,\r\n        uint256 participant1_locked_amount,\r\n        bytes32 participant1_locksroot,\r\n        address participant2,\r\n        uint256 participant2_transferred_amount,\r\n        uint256 participant2_locked_amount,\r\n        bytes32 participant2_locksroot\r\n    )\r\n        public\r\n    {\r\n        settleChannel2(\r\n            channel_identifier,\r\n            SettleInput({\r\n                participant: participant1,\r\n                transferred_amount: participant1_transferred_amount,\r\n                locked_amount: participant1_locked_amount,\r\n                locksroot: participant1_locksroot\r\n            }),\r\n            SettleInput({\r\n                participant: participant2,\r\n                transferred_amount: participant2_transferred_amount,\r\n                locked_amount: participant2_locked_amount,\r\n                locksroot: participant2_locksroot\r\n            })\r\n        );\r\n    }\r\n\r\n    function settleChannel2(\r\n        uint256 channel_identifier,\r\n        SettleInput memory participant1_settlement,\r\n        SettleInput memory participant2_settlement\r\n    )\r\n        public\r\n    {\r\n        // There are several requirements that this function MUST enforce:\r\n        // - it MUST never fail; therefore, any overflows or underflows must be\r\n        // handled gracefully\r\n        // - it MUST ensure that if participants use the latest valid balance proofs,\r\n        // provided by the official Raiden client, the participants will be able\r\n        // to receive correct final balances at the end of the channel lifecycle\r\n        // - it MUST ensure that the participants cannot cheat by providing an\r\n        // old, valid balance proof of their partner; meaning that their partner MUST\r\n        // receive at least the amount of tokens that he would have received if\r\n        // the latest valid balance proofs are used.\r\n        // - the contract cannot determine if a balance proof is invalid (values\r\n        // are not within the constraints enforced by the official Raiden client),\r\n        // therefore it cannot ensure correctness. Users MUST use the official\r\n        // Raiden clients for signing balance proofs.\r\n\r\n        address participant1 = participant1_settlement.participant;\r\n        address participant2 = participant2_settlement.participant;\r\n        require(channel_identifier == getChannelIdentifier(participant1, participant2));\r\n\r\n        bytes32 pair_hash;\r\n\r\n        pair_hash = getParticipantsHash(participant1, participant2);\r\n        Channel storage channel = channels[channel_identifier];\r\n\r\n        require(channel.state == ChannelState.Closed);\r\n\r\n        // Settlement window must be over\r\n        require(channel.settle_block_number < block.number);\r\n\r\n        Participant storage participant1_state = channel.participants[participant1];\r\n        Participant storage participant2_state = channel.participants[participant2];\r\n\r\n        require(verifyBalanceHashData(\r\n            participant1_state,\r\n            participant1_settlement\r\n        ));\r\n\r\n        require(verifyBalanceHashData(\r\n            participant2_state,\r\n            participant2_settlement\r\n        ));\r\n\r\n        // We are calculating the final token amounts that need to be\r\n        // transferred to the participants now and the amount of tokens that\r\n        // need to remain locked in the contract. These tokens can be unlocked\r\n        // by calling `unlock`.\r\n        // participant1_transferred_amount = the amount of tokens that\r\n        //   participant1 will receive in this transaction.\r\n        // participant2_transferred_amount = the amount of tokens that\r\n        //   participant2 will receive in this transaction.\r\n        // participant1_locked_amount = the amount of tokens remaining in the\r\n        //   contract, representing pending transfers from participant1 to participant2.\r\n        // participant2_locked_amount = the amount of tokens remaining in the\r\n        //   contract, representing pending transfers from participant2 to participant1.\r\n        // We are reusing variables due to the local variables number limit.\r\n        // For better readability this can be refactored further.\r\n        (\r\n            participant1_settlement.transferred_amount,\r\n            participant2_settlement.transferred_amount,\r\n            participant1_settlement.locked_amount,\r\n            participant2_settlement.locked_amount\r\n        ) = getSettleTransferAmounts(\r\n            participant1_state,\r\n            participant1_settlement.transferred_amount,\r\n            participant1_settlement.locked_amount,\r\n            participant2_state,\r\n            participant2_settlement.transferred_amount,\r\n            participant2_settlement.locked_amount\r\n        );\r\n\r\n        // Remove the channel data from storage\r\n        delete channel.participants[participant1];\r\n        delete channel.participants[participant2];\r\n        delete channels[channel_identifier];\r\n\r\n        // Remove the pair's channel counter\r\n        delete participants_hash_to_channel_identifier[pair_hash];\r\n\r\n        // Store balance data needed for `unlock`, including the calculated\r\n        // locked amounts remaining in the contract.\r\n        storeUnlockData(\r\n            channel_identifier,\r\n            participant1_settlement,\r\n            participant2\r\n        );\r\n        storeUnlockData(\r\n            channel_identifier,\r\n            participant2_settlement,\r\n            participant1\r\n        );\r\n\r\n        emit ChannelSettled(\r\n            channel_identifier,\r\n            participant1_settlement.transferred_amount,\r\n            participant1_settlement.locksroot,\r\n            participant2_settlement.transferred_amount,\r\n            participant2_settlement.locksroot\r\n        );\r\n\r\n        // Do the actual token transfers\r\n        if (participant1_settlement.transferred_amount > 0) {\r\n            require(token.transfer(participant1, participant1_settlement.transferred_amount));\r\n        }\r\n\r\n        if (participant2_settlement.transferred_amount > 0) {\r\n            require(token.transfer(participant2, participant2_settlement.transferred_amount));\r\n        }\r\n    }\r\n\r\n    /// @notice Unlocks all pending off-chain transfers from `sender` to\r\n    /// `receiver` and sends the locked tokens corresponding to locks with\r\n    /// secrets registered on-chain to the `receiver`. Locked tokens\r\n    /// corresponding to locks where the secret was not revealed on-chain will\r\n    /// return to the `sender`. Anyone can call unlock.\r\n    /// @param channel_identifier Identifier for the channel on which this\r\n    /// operation takes place\r\n    /// @param receiver Address who will receive the claimable unlocked\r\n    /// tokens\r\n    /// @param sender Address who sent the pending transfers and will receive\r\n    /// the unclaimable unlocked tokens\r\n    /// @param locks All pending locks concatenated in order of creation\r\n    /// that `sender` sent to `receiver`\r\n    function unlock(\r\n        uint256 channel_identifier,\r\n        address receiver,\r\n        address sender,\r\n        bytes memory locks\r\n    )\r\n        public\r\n    {\r\n        // Channel represented by channel_identifier must be settled and\r\n        // channel data deleted\r\n        require(channel_identifier != getChannelIdentifier(receiver, sender));\r\n\r\n        // After the channel is settled the storage is cleared, therefore the\r\n        // value will be NonExistent and not Settled. The value Settled is used\r\n        // for the external APIs\r\n        require(channels[channel_identifier].state == ChannelState.NonExistent);\r\n\r\n        bytes32 unlock_key;\r\n        bytes32 computed_locksroot;\r\n        uint256 unlocked_amount;\r\n        uint256 locked_amount;\r\n        uint256 returned_tokens;\r\n\r\n        // Calculate the locksroot for the pending transfers and the amount of\r\n        // tokens corresponding to the locked transfers with secrets revealed\r\n        // on chain.\r\n        (computed_locksroot, unlocked_amount) = getHashAndUnlockedAmount(\r\n            locks\r\n        );\r\n\r\n        // The sender must have a non-empty locksroot on-chain that must be\r\n        // the same as the computed locksroot.\r\n        // Get the amount of tokens that have been left in the contract, to\r\n        // account for the pending transfers `sender` -> `receiver`.\r\n        unlock_key = getUnlockIdentifier(channel_identifier, sender, receiver);\r\n        UnlockData storage unlock_data = unlock_identifier_to_unlock_data[unlock_key];\r\n        locked_amount = unlock_data.locked_amount;\r\n\r\n        // Locksroot must be the same as the computed locksroot\r\n        require(unlock_data.locksroot == computed_locksroot);\r\n\r\n        // There are no pending transfers if the locked_amount is 0.\r\n        // Transaction must fail\r\n        require(locked_amount > 0);\r\n\r\n        // Make sure we don't transfer more tokens than previously reserved in\r\n        // the smart contract.\r\n        unlocked_amount = TokenNetworkUtils.min(unlocked_amount, locked_amount);\r\n\r\n        // Transfer the rest of the tokens back to the sender\r\n        returned_tokens = locked_amount - unlocked_amount;\r\n\r\n        // Remove sender's unlock data\r\n        delete unlock_identifier_to_unlock_data[unlock_key];\r\n\r\n        emit ChannelUnlocked(\r\n            channel_identifier,\r\n            receiver,\r\n            sender,\r\n            computed_locksroot,\r\n            unlocked_amount,\r\n            returned_tokens\r\n        );\r\n\r\n        // Transfer the unlocked tokens to the receiver. unlocked_amount can\r\n        // be 0\r\n        if (unlocked_amount > 0) {\r\n            require(token.transfer(receiver, unlocked_amount));\r\n        }\r\n\r\n        // Transfer the rest of the tokens back to the sender\r\n        if (returned_tokens > 0) {\r\n            require(token.transfer(sender, returned_tokens));\r\n        }\r\n\r\n        // At this point, this should always be true\r\n        assert(locked_amount >= returned_tokens);\r\n        assert(locked_amount >= unlocked_amount);\r\n    }\r\n\r\n    /* /// @notice Cooperatively settles the balances between the two channel\r\n    /// participants and transfers the agreed upon token amounts to the\r\n    /// participants. After this the channel lifecycle has ended and no more\r\n    /// operations can be done on it.\r\n    /// @param channel_identifier Identifier for the channel on which this\r\n    /// operation takes place\r\n    /// @param participant1_address Address of channel participant\r\n    /// @param participant1_balance Amount of tokens that `participant1_address`\r\n    /// must receive when the channel is settled and removed\r\n    /// @param participant2_address Address of the other channel participant\r\n    /// @param participant2_balance Amount of tokens that `participant2_address`\r\n    /// must receive when the channel is settled and removed\r\n    /// @param participant1_signature Signature of `participant1_address` on the\r\n    /// cooperative settle message\r\n    /// @param participant2_signature Signature of `participant2_address` on the\r\n    /// cooperative settle message\r\n    function cooperativeSettle(\r\n        uint256 channel_identifier,\r\n        address participant1_address,\r\n        uint256 participant1_balance,\r\n        address participant2_address,\r\n        uint256 participant2_balance,\r\n        bytes participant1_signature,\r\n        bytes participant2_signature\r\n    )\r\n        public\r\n    {\r\n        require(channel_identifier == getChannelIdentifier(\r\n            participant1_address,\r\n            participant2_address\r\n        ));\r\n        bytes32 pair_hash;\r\n        address participant1;\r\n        address participant2;\r\n        uint256 total_available_deposit;\r\n\r\n        pair_hash = getParticipantsHash(participant1_address, participant2_address);\r\n        Channel storage channel = channels[channel_identifier];\r\n\r\n        require(channel.state == ChannelState.Opened);\r\n\r\n        participant1 = TokenNetworkUtils.recoverAddressFromCooperativeSettleSignature(\r\n            channel_identifier,\r\n            participant1_address,\r\n            participant1_balance,\r\n            participant2_address,\r\n            participant2_balance,\r\n            participant1_signature\r\n        );\r\n        // The provided address must be the same as the recovered one\r\n        require(participant1 == participant1_address);\r\n\r\n        participant2 = TokenNetworkUtils.recoverAddressFromCooperativeSettleSignature(\r\n            channel_identifier,\r\n            participant1_address,\r\n            participant1_balance,\r\n            participant2_address,\r\n            participant2_balance,\r\n            participant2_signature\r\n        );\r\n        // The provided address must be the same as the recovered one\r\n        require(participant2 == participant2_address);\r\n\r\n        Participant storage participant1_state = channel.participants[participant1];\r\n        Participant storage participant2_state = channel.participants[participant2];\r\n\r\n        total_available_deposit = getChannelAvailableDeposit(\r\n            participant1_state,\r\n            participant2_state\r\n        );\r\n        // The sum of the provided balances must be equal to the total\r\n        // available deposit\r\n        require(total_available_deposit == (participant1_balance + participant2_balance));\r\n        // Overflow check for the balances addition from the above check.\r\n        // This overflow should never happen if the token.transfer function is implemented\r\n        // correctly. We do not control the token implementation, therefore we add this\r\n        // check for safety.\r\n        require(participant1_balance <= participant1_balance + participant2_balance);\r\n\r\n        // Remove channel data from storage before doing the token transfers\r\n        delete channel.participants[participant1];\r\n        delete channel.participants[participant2];\r\n        delete channels[channel_identifier];\r\n\r\n        // Remove the pair's channel counter\r\n        delete participants_hash_to_channel_identifier[pair_hash];\r\n\r\n        emit ChannelSettled(channel_identifier, participant1_balance, participant2_balance);\r\n\r\n        // Do the token transfers\r\n        if (participant1_balance > 0) {\r\n            require(token.transfer(participant1, participant1_balance));\r\n        }\r\n\r\n        if (participant2_balance > 0) {\r\n            require(token.transfer(participant2, participant2_balance));\r\n        }\r\n    } */\r\n\r\n    /// @notice Returns the unique identifier for the channel given by the\r\n    /// contract\r\n    /// @param participant Address of a channel participant\r\n    /// @param partner Address of the other channel participant\r\n    /// @return Unique identifier for the channel. It can be 0 if channel does\r\n    /// not exist\r\n    function getChannelIdentifier(address participant, address partner)\r\n        public\r\n        view\r\n        returns (uint256)\r\n    {\r\n        require(participant != address(0x0));\r\n        require(partner != address(0x0));\r\n        require(participant != partner);\r\n\r\n        bytes32 pair_hash = getParticipantsHash(participant, partner);\r\n        return participants_hash_to_channel_identifier[pair_hash];\r\n    }\r\n\r\n    /// @dev Returns the channel specific data.\r\n    /// @param channel_identifier Identifier for the channel on which this\r\n    /// operation takes place\r\n    /// @param participant1 Address of a channel participant\r\n    /// @param participant2 Address of the other channel participant\r\n    /// @return Channel settle_block_number and state\r\n    /// @notice The contract cannot really distinguish Settled and Removed\r\n    /// states, especially when wrong participants are given as input.\r\n    /// The contract does not remember the participants of the channel\r\n    function getChannelInfo(\r\n        uint256 channel_identifier,\r\n        address participant1,\r\n        address participant2\r\n    )\r\n        external\r\n        view\r\n        returns (uint256, ChannelState)\r\n    {\r\n        bytes32 unlock_key1;\r\n        bytes32 unlock_key2;\r\n\r\n        Channel storage channel = channels[channel_identifier];\r\n        ChannelState state = channel.state;  // This must **not** update the storage\r\n\r\n        if (state == ChannelState.NonExistent &&\r\n            channel_identifier > 0 &&\r\n            channel_identifier <= channel_counter\r\n        ) {\r\n            // The channel has been settled, channel data is removed Therefore,\r\n            // the channel state in storage is actually `0`, or `NonExistent`\r\n            // However, for this view function, we return `Settled`, in order\r\n            // to provide a consistent external API\r\n            state = ChannelState.Settled;\r\n\r\n            // We might still have data stored for future unlock operations\r\n            // Only if we do not, we can consider the channel as `Removed`\r\n            unlock_key1 = getUnlockIdentifier(channel_identifier, participant1, participant2);\r\n            UnlockData storage unlock_data1 = unlock_identifier_to_unlock_data[unlock_key1];\r\n\r\n            unlock_key2 = getUnlockIdentifier(channel_identifier, participant2, participant1);\r\n            UnlockData storage unlock_data2 = unlock_identifier_to_unlock_data[unlock_key2];\r\n\r\n            if (unlock_data1.locked_amount == 0 && unlock_data2.locked_amount == 0) {\r\n                state = ChannelState.Removed;\r\n            }\r\n        }\r\n\r\n        return (\r\n            channel.settle_block_number,\r\n            state\r\n        );\r\n    }\r\n\r\n    /// @dev Returns the channel specific data.\r\n    /// @param channel_identifier Identifier for the channel on which this\r\n    /// operation takes place\r\n    /// @param participant Address of the channel participant whose data will be\r\n    /// returned\r\n    /// @param partner Address of the channel partner\r\n    /// @return Participant's deposit, withdrawn_amount, whether the participant\r\n    /// has called `closeChannel` or not, balance_hash, nonce, locksroot,\r\n    /// locked_amount\r\n    function getChannelParticipantInfo(\r\n            uint256 channel_identifier,\r\n            address participant,\r\n            address partner\r\n    )\r\n        external\r\n        view\r\n        returns (uint256, uint256, bool, bytes32, uint256, bytes32, uint256)\r\n    {\r\n        bytes32 unlock_key;\r\n\r\n        Participant storage participant_state = channels[channel_identifier].participants[\r\n            participant\r\n        ];\r\n        unlock_key = getUnlockIdentifier(channel_identifier, participant, partner);\r\n        UnlockData storage unlock_data = unlock_identifier_to_unlock_data[unlock_key];\r\n\r\n        return (\r\n            participant_state.deposit,\r\n            participant_state.withdrawn_amount,\r\n            participant_state.is_the_closer,\r\n            participant_state.balance_hash,\r\n            participant_state.nonce,\r\n            unlock_data.locksroot,\r\n            unlock_data.locked_amount\r\n        );\r\n    }\r\n\r\n    /// @dev Get the hash of the participant addresses, ordered\r\n    /// lexicographically\r\n    /// @param participant Address of a channel participant\r\n    /// @param partner Address of the other channel participant\r\n    function getParticipantsHash(address participant, address partner)\r\n        public\r\n        pure\r\n        returns (bytes32)\r\n    {\r\n        require(participant != address(0x0));\r\n        require(partner != address(0x0));\r\n        require(participant != partner);\r\n\r\n        if (participant < partner) {\r\n            return keccak256(abi.encodePacked(participant, partner));\r\n        } else {\r\n            return keccak256(abi.encodePacked(partner, participant));\r\n        }\r\n    }\r\n\r\n    /// @dev Get the hash of the channel identifier and the participant\r\n    /// addresses (whose ordering matters). The hash might be useful for\r\n    /// the receiver to look up the appropriate UnlockData to claim\r\n    /// @param channel_identifier Identifier for the channel which the\r\n    /// UnlockData is about\r\n    /// @param sender Sender of the pending transfers that the UnlockData\r\n    /// represents\r\n    /// @param receiver Receiver of the pending transfers that the UnlockData\r\n    /// represents\r\n    function getUnlockIdentifier(\r\n        uint256 channel_identifier,\r\n        address sender,\r\n        address receiver\r\n    )\r\n        public\r\n        pure\r\n        returns (bytes32)\r\n    {\r\n        require(sender != receiver);\r\n        return keccak256(abi.encodePacked(channel_identifier, sender, receiver));\r\n    }\r\n\r\n    function updateBalanceProofData(\r\n        Channel storage channel,\r\n        address participant,\r\n        uint256 nonce,\r\n        bytes32 balance_hash\r\n    )\r\n        internal\r\n    {\r\n        Participant storage participant_state = channel.participants[participant];\r\n\r\n        // Multiple calls to updateNonClosingBalanceProof can be made and we\r\n        // need to store the last known balance proof data.\r\n        // This line prevents Monitoring Services from getting rewards\r\n        // again and again using the same reward proof.\r\n        require(nonce > participant_state.nonce);\r\n\r\n        participant_state.nonce = nonce;\r\n        participant_state.balance_hash = balance_hash;\r\n    }\r\n\r\n    function storeUnlockData(\r\n        uint256 channel_identifier,\r\n        SettleInput memory settle_input,\r\n        address receiver\r\n    )\r\n        internal\r\n    {\r\n        // If there are transfers to unlock, store the locksroot and total\r\n        // amount of tokens\r\n        if (settle_input.locked_amount == 0) {\r\n            return;\r\n        }\r\n\r\n        bytes32 key = getUnlockIdentifier(channel_identifier, settle_input.participant, receiver);\r\n        UnlockData storage unlock_data = unlock_identifier_to_unlock_data[key];\r\n        unlock_data.locksroot = settle_input.locksroot;\r\n        unlock_data.locked_amount = settle_input.locked_amount;\r\n    }\r\n\r\n    function getChannelAvailableDeposit(\r\n        Participant storage participant1_state,\r\n        Participant storage participant2_state\r\n    )\r\n        internal\r\n        view\r\n        returns (uint256 total_available_deposit)\r\n    {\r\n        total_available_deposit = (\r\n            participant1_state.deposit +\r\n            participant2_state.deposit -\r\n            participant1_state.withdrawn_amount -\r\n            participant2_state.withdrawn_amount\r\n        );\r\n    }\r\n\r\n    /// @dev Function that calculates the amount of tokens that the participants\r\n    /// will receive when calling settleChannel.\r\n    /// Check https://github.com/raiden-network/raiden-contracts/issues/188 for the settlement\r\n    /// algorithm analysis and explanations.\r\n    function getSettleTransferAmounts(\r\n        Participant storage participant1_state,\r\n        uint256 participant1_transferred_amount,\r\n        uint256 participant1_locked_amount,\r\n        Participant storage participant2_state,\r\n        uint256 participant2_transferred_amount,\r\n        uint256 participant2_locked_amount\r\n    )\r\n        private\r\n        view\r\n        returns (uint256, uint256, uint256, uint256)\r\n    {\r\n        // The scope of this function is to compute the settlement amounts that\r\n        // the two channel participants will receive when calling settleChannel\r\n        // and the locked amounts that remain in the contract, to account for\r\n        // the pending, not finalized transfers, that will be received by the\r\n        // participants when calling `unlock`.\r\n\r\n        // The amount of tokens that participant1 MUST receive at the end of\r\n        // the channel lifecycle (after settleChannel and unlock) is:\r\n        // B1 = D1 - W1 + T2 - T1 + Lc2 - Lc1\r\n\r\n        // The amount of tokens that participant2 MUST receive at the end of\r\n        // the channel lifecycle (after settleChannel and unlock) is:\r\n        // B2 = D2 - W2 + T1 - T2 + Lc1 - Lc2\r\n\r\n        // B1 + B2 = TAD = D1 + D2 - W1 - W2\r\n        // TAD = total available deposit at settlement time\r\n\r\n        // L1 = Lc1 + Lu1\r\n        // L2 = Lc2 + Lu2\r\n\r\n        // where:\r\n        // B1 = final balance of participant1 after the channel is removed\r\n        // D1 = total amount deposited by participant1 into the channel\r\n        // W1 = total amount withdrawn by participant1 from the channel\r\n        // T2 = total amount transferred by participant2 to participant1 (finalized transfers)\r\n        // T1 = total amount transferred by participant1 to participant2 (finalized transfers)\r\n        // L1 = total amount of tokens locked in pending transfers, sent by\r\n        //   participant1 to participant2\r\n        // L2 = total amount of tokens locked in pending transfers, sent by\r\n        //   participant2 to participant1\r\n        // Lc2 = the amount that can be claimed by participant1 from the pending\r\n        //   transfers (that have not been finalized off-chain), sent by\r\n        //   participant2 to participant1. These are part of the locked amount\r\n        //   value from participant2's balance proof. They are considered claimed\r\n        //   if the secret corresponding to these locked transfers was registered\r\n        //   on-chain, in the SecretRegistry contract, before the lock's expiration.\r\n        // Lu1 = unclaimable locked amount from L1\r\n        // Lc1 = the amount that can be claimed by participant2 from the pending\r\n        //   transfers (that have not been finalized off-chain),\r\n        //   sent by participant1 to participant2\r\n        // Lu2 = unclaimable locked amount from L2\r\n\r\n        // Notes:\r\n        // 1) The unclaimble tokens from a locked amount will return to the sender.\r\n        // At the time of calling settleChannel, the TokenNetwork contract does\r\n        // not know what locked amounts are claimable or unclaimable.\r\n        // 2) There are some Solidity constraints that make the calculations\r\n        // more difficult: attention to overflows and underflows, that MUST be\r\n        // handled without throwing.\r\n\r\n        // Cases that require attention:\r\n        // case1. If participant1 does NOT provide a balance proof or provides\r\n        // an old balance proof.  participant2_transferred_amount can be [0,\r\n        // real_participant2_transferred_amount) We MUST NOT punish\r\n        // participant2.\r\n        // case2. If participant2 does NOT provide a balance proof or provides\r\n        // an old balance proof.  participant1_transferred_amount can be [0,\r\n        // real_participant1_transferred_amount) We MUST NOT punish\r\n        // participant1.\r\n        // case3. If neither participants provide a balance proof, we just\r\n        // subtract their withdrawn amounts from their deposits.\r\n\r\n        // This is why, the algorithm implemented in Solidity is:\r\n        // (explained at each step, below)\r\n        // RmaxP1 = (T2 + L2) - (T1 + L1) + D1 - W1\r\n        // RmaxP1 = min(TAD, RmaxP1)\r\n        // RmaxP2 = TAD - RmaxP1\r\n        // SL2 = min(RmaxP1, L2)\r\n        // S1 = RmaxP1 - SL2\r\n        // SL1 = min(RmaxP2, L1)\r\n        // S2 = RmaxP2 - SL1\r\n\r\n        // where:\r\n        // RmaxP1 = due to possible over/underflows that only appear when using\r\n        //    old balance proofs & the fact that settlement balance calculation\r\n        //    is symmetric (we can calculate either RmaxP1 and RmaxP2 first,\r\n        //    order does not affect result), this is a convention used to determine\r\n        //    the maximum receivable amount of participant1 at settlement time\r\n        // S1 = amount received by participant1 when calling settleChannel\r\n        // SL1 = the maximum amount from L1 that can be locked in the\r\n        //   TokenNetwork contract when calling settleChannel (due to overflows\r\n        //   that only happen when using old balance proofs)\r\n        // S2 = amount received by participant2 when calling settleChannel\r\n        // SL2 = the maximum amount from L2 that can be locked in the\r\n        //   TokenNetwork contract when calling settleChannel (due to overflows\r\n        //   that only happen when using old balance proofs)\r\n\r\n        uint256 participant1_amount;\r\n        uint256 participant2_amount;\r\n        uint256 total_available_deposit;\r\n\r\n        SettlementData memory participant1_settlement;\r\n        SettlementData memory participant2_settlement;\r\n\r\n        participant1_settlement.deposit = participant1_state.deposit;\r\n        participant1_settlement.withdrawn = participant1_state.withdrawn_amount;\r\n        participant1_settlement.transferred = participant1_transferred_amount;\r\n        participant1_settlement.locked = participant1_locked_amount;\r\n\r\n        participant2_settlement.deposit = participant2_state.deposit;\r\n        participant2_settlement.withdrawn = participant2_state.withdrawn_amount;\r\n        participant2_settlement.transferred = participant2_transferred_amount;\r\n        participant2_settlement.locked = participant2_locked_amount;\r\n\r\n        // TAD = D1 + D2 - W1 - W2 = total available deposit at settlement time\r\n        total_available_deposit = getChannelAvailableDeposit(\r\n            participant1_state,\r\n            participant2_state\r\n        );\r\n\r\n        // RmaxP1 = (T2 + L2) - (T1 + L1) + D1 - W1\r\n        // This amount is the maximum possible amount that participant1 can\r\n        // receive at settlement time and also contains the entire locked amount\r\n        //  of the pending transfers from participant2 to participant1.\r\n        participant1_amount = getMaxPossibleReceivableAmount(\r\n            participant1_settlement,\r\n            participant2_settlement\r\n        );\r\n\r\n        // RmaxP1 = min(TAD, RmaxP1)\r\n        // We need to bound this to the available channel deposit in order to\r\n        // not send tokens from other channels. The only case where TAD is\r\n        // smaller than RmaxP1 is when at least one balance proof is old.\r\n        participant1_amount = TokenNetworkUtils.min(participant1_amount, total_available_deposit);\r\n\r\n        // RmaxP2 = TAD - RmaxP1\r\n        // Now it is safe to subtract without underflow\r\n        participant2_amount = total_available_deposit - participant1_amount;\r\n\r\n        // SL2 = min(RmaxP1, L2)\r\n        // S1 = RmaxP1 - SL2\r\n        // Both operations are done by failsafe_subtract\r\n        // We take out participant2's pending transfers locked amount, bounding\r\n        // it by the maximum receivable amount of participant1\r\n        (participant1_amount, participant2_locked_amount) = TokenNetworkUtils.failsafe_subtract(\r\n            participant1_amount,\r\n            participant2_locked_amount\r\n        );\r\n\r\n        // SL1 = min(RmaxP2, L1)\r\n        // S2 = RmaxP2 - SL1\r\n        // Both operations are done by failsafe_subtract\r\n        // We take out participant1's pending transfers locked amount, bounding\r\n        // it by the maximum receivable amount of participant2\r\n        (participant2_amount, participant1_locked_amount) = TokenNetworkUtils.failsafe_subtract(\r\n            participant2_amount,\r\n            participant1_locked_amount\r\n        );\r\n\r\n        // This should never throw:\r\n        // S1 and S2 MUST be smaller than TAD\r\n        assert(participant1_amount <= total_available_deposit);\r\n        assert(participant2_amount <= total_available_deposit);\r\n        // S1 + S2 + SL1 + SL2 == TAD\r\n        assert(total_available_deposit == (\r\n            participant1_amount +\r\n            participant2_amount +\r\n            participant1_locked_amount +\r\n            participant2_locked_amount\r\n        ));\r\n\r\n        return (\r\n            participant1_amount,\r\n            participant2_amount,\r\n            participant1_locked_amount,\r\n            participant2_locked_amount\r\n        );\r\n    }\r\n\r\n    function getMaxPossibleReceivableAmount(\r\n        SettlementData memory participant1_settlement,\r\n        SettlementData memory participant2_settlement\r\n    )\r\n        internal\r\n        pure\r\n        returns (uint256)\r\n    {\r\n        return TokenNetworkUtils.getMaxPossibleReceivableAmount(\r\n            participant1_settlement.deposit,\r\n            participant1_settlement.withdrawn,\r\n            participant1_settlement.transferred,\r\n            participant1_settlement.locked,\r\n            participant2_settlement.deposit,\r\n            participant2_settlement.withdrawn,\r\n            participant2_settlement.transferred,\r\n            participant2_settlement.locked\r\n        );\r\n    }\r\n\r\n    function verifyBalanceHashData(\r\n        Participant storage participant,\r\n        SettleInput memory settle_input\r\n    )\r\n        internal\r\n        view\r\n        returns (bool)\r\n    {\r\n        // When no balance proof has been provided, we need to check this\r\n        // separately because hashing values of 0 outputs a value != 0\r\n        if (participant.balance_hash == 0 &&\r\n            settle_input.transferred_amount == 0 &&\r\n            settle_input.locked_amount == 0\r\n            /* locksroot is ignored. */\r\n        ) {\r\n            return true;\r\n        }\r\n\r\n        // Make sure the hash of the provided state is the same as the stored\r\n        // balance_hash\r\n        return participant.balance_hash == keccak256(abi.encodePacked(\r\n            settle_input.transferred_amount,\r\n            settle_input.locked_amount,\r\n            settle_input.locksroot\r\n        ));\r\n    }\r\n\r\n    /// @dev Calculates the hash of the pending transfers data and\r\n    /// calculates the amount of tokens that can be unlocked because the secret\r\n    /// was registered on-chain.\r\n    function getHashAndUnlockedAmount(bytes memory locks)\r\n        internal\r\n        view\r\n        returns (bytes32, uint256)\r\n    {\r\n        uint256 length = locks.length;\r\n\r\n        // each lock has this form:\r\n        // (locked_amount || expiration_block || secrethash) = 3 * 32 bytes\r\n        require(length % 96 == 0);\r\n\r\n        uint256 i;\r\n        uint256 total_unlocked_amount;\r\n        uint256 unlocked_amount;\r\n        bytes32 total_hash;\r\n\r\n        for (i = 32; i < length; i += 96) {\r\n            unlocked_amount = getLockedAmountFromLock(locks, i);\r\n            total_unlocked_amount += unlocked_amount;\r\n        }\r\n\r\n        total_hash = keccak256(locks);\r\n\r\n        return (total_hash, total_unlocked_amount);\r\n    }\r\n\r\n    function getLockedAmountFromLock(bytes memory locks, uint256 offset)\r\n        internal\r\n        view\r\n        returns (uint256)\r\n    {\r\n        uint256 expiration_block;\r\n        uint256 locked_amount;\r\n        uint256 reveal_block;\r\n        bytes32 secrethash;\r\n\r\n        if (locks.length <= offset) {\r\n            return 0;\r\n        }\r\n\r\n        assembly { // solium-disable-line security/no-inline-assembly\r\n            expiration_block := mload(add(locks, offset))\r\n            locked_amount := mload(add(locks, add(offset, 32)))\r\n            secrethash := mload(add(locks, add(offset, 64)))\r\n        }\r\n\r\n        // Check if the lock's secret was revealed in the SecretRegistry The\r\n        // secret must have been revealed in the SecretRegistry contract before\r\n        // the lock's expiration_block in order for the hash time lock transfer\r\n        // to be successful.\r\n        reveal_block = secret_registry.getSecretRevealBlockHeight(secrethash);\r\n        if (reveal_block == 0 || expiration_block <= reveal_block) {\r\n            locked_amount = 0;\r\n        }\r\n\r\n        return locked_amount;\r\n    }\r\n}\r\n"
    },
    "data/source/raiden/TokenNetworkRegistry.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n/* solium-disable error-reason */\r\npragma solidity 0.7.6;\r\n\r\nimport \"./Utils.sol\";\r\nimport \"./Token.sol\";\r\nimport \"./TokenNetwork.sol\";\r\n\r\n\r\n/// @title TokenNetworkRegistry\r\n/// @notice The TokenNetwork Registry deploys new TokenNetwork contracts for the\r\n/// Raiden Network protocol.\r\ncontract TokenNetworkRegistry is Utils {\r\n    address public secret_registry_address;\r\n    uint256 public chain_id;\r\n    uint256 public settlement_timeout_min;\r\n    uint256 public settlement_timeout_max;\r\n    uint256 public max_token_networks;\r\n\r\n    // Only for the limited Red Eyes release\r\n    address public deprecation_executor;\r\n    uint256 public token_network_created = 0;\r\n\r\n    // Token address => TokenNetwork address\r\n    mapping(address => address) public token_to_token_networks;\r\n\r\n    event TokenNetworkCreated(address indexed token_address, address indexed token_network_address);\r\n\r\n    modifier canCreateTokenNetwork() {\r\n        require(token_network_created < max_token_networks, \"registry full\");\r\n        _;\r\n    }\r\n\r\n    /// @param _secret_registry_address The address of SecretRegistry that's used by all\r\n    /// TokenNetworks created by this contract\r\n    /// @param _chain_id EIP-155 Chain-ID of the chain where this contract is deployed\r\n    /// @param _settlement_timeout_min The shortest settlement period (in number of blocks)\r\n    /// that can be chosen at the channel opening\r\n    /// @param _settlement_timeout_max The longest settlement period (in number of blocks)\r\n    /// that can be chosen at the channel opening\r\n    /// @param _max_token_networks the number of tokens that can be registered\r\n    /// MAX_UINT256 means no limits\r\n    constructor(\r\n        address _secret_registry_address,\r\n        uint256 _chain_id,\r\n        uint256 _settlement_timeout_min,\r\n        uint256 _settlement_timeout_max,\r\n        uint256 _max_token_networks\r\n    ) {\r\n        require(_chain_id > 0);\r\n        require(_settlement_timeout_min > 0);\r\n        require(_settlement_timeout_max > 0);\r\n        require(_settlement_timeout_max > _settlement_timeout_min);\r\n        require(_secret_registry_address != address(0x0));\r\n        require(contractExists(_secret_registry_address));\r\n        require(_max_token_networks > 0);\r\n        secret_registry_address = _secret_registry_address;\r\n        chain_id = _chain_id;\r\n        settlement_timeout_min = _settlement_timeout_min;\r\n        settlement_timeout_max = _settlement_timeout_max;\r\n        max_token_networks = _max_token_networks;\r\n\r\n        deprecation_executor = msg.sender;\r\n    }\r\n\r\n    /// @notice Deploy a new TokenNetwork contract for the Token deployed at\r\n    /// `_token_address`\r\n    /// @param _token_address Ethereum address of an already deployed token, to\r\n    /// be used in the new TokenNetwork contract\r\n    function createERC20TokenNetwork(\r\n        address _token_address,\r\n        uint256 _channel_participant_deposit_limit,\r\n        uint256 _token_network_deposit_limit\r\n    )\r\n        external\r\n        canCreateTokenNetwork\r\n        returns (address token_network_address)\r\n    {\r\n        require(token_to_token_networks[_token_address] == address(0x0));\r\n\r\n        // We limit the number of token networks to 1 for the Bug Bounty release\r\n        token_network_created = token_network_created + 1;\r\n\r\n        TokenNetwork token_network;\r\n\r\n        // Token contract checks are in the corresponding TokenNetwork contract\r\n        token_network = new TokenNetwork(\r\n            _token_address,\r\n            secret_registry_address,\r\n            chain_id,\r\n            settlement_timeout_min,\r\n            settlement_timeout_max,\r\n            deprecation_executor,\r\n            _channel_participant_deposit_limit,\r\n            _token_network_deposit_limit\r\n        );\r\n\r\n        token_network_address = address(token_network);\r\n\r\n        token_to_token_networks[_token_address] = token_network_address;\r\n        emit TokenNetworkCreated(_token_address, token_network_address);\r\n\r\n        return token_network_address;\r\n    }\r\n}\r\n\r\n// MIT License\r\n\r\n// Copyright (c) 2018\r\n\r\n// Permission is hereby granted, free of charge, to any person obtaining a copy\r\n// of this software and associated documentation files (the \"Software\"), to deal\r\n// in the Software without restriction, including without limitation the rights\r\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\r\n// copies of the Software, and to permit persons to whom the Software is\r\n// furnished to do so, subject to the following conditions:\r\n\r\n// The above copyright notice and this permission notice shall be included in all\r\n// copies or substantial portions of the Software.\r\n\r\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\r\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\r\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\r\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\r\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\r\n// SOFTWARE.\r\n"
    },
    "data/source/lib/TokenNetworkUtils.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n/* solium-disable indentation */\r\npragma solidity 0.7.6;\r\n\r\nimport \"./ECVerify.sol\";\r\nimport \"./MessageType.sol\";\r\n\r\nlibrary TokenNetworkUtils {\r\n    string internal constant signature_prefix = \"\\x19Ethereum Signed Message:\\n\";\r\n\r\n    function getMaxPossibleReceivableAmount(\r\n        uint256 participant1_deposit,\r\n        uint256 participant1_withdrawn,\r\n        uint256 participant1_transferred,\r\n        uint256 participant1_locked,\r\n        uint256 participant2_deposit,\r\n        uint256 participant2_withdrawn,\r\n        uint256 participant2_transferred,\r\n        uint256 participant2_locked\r\n    )\r\n        internal\r\n        pure\r\n        returns (uint256)\r\n    {\r\n        uint256 participant1_max_transferred;\r\n        uint256 participant2_max_transferred;\r\n        uint256 participant1_net_max_received;\r\n        uint256 participant1_max_amount;\r\n\r\n        // This is the maximum possible amount that participant1 could transfer\r\n        // to participant2, if all the pending lock secrets have been\r\n        // registered\r\n        participant1_max_transferred = failsafe_addition(\r\n            participant1_transferred,\r\n            participant1_locked\r\n        );\r\n\r\n        // This is the maximum possible amount that participant2 could transfer\r\n        // to participant1, if all the pending lock secrets have been\r\n        // registered\r\n        participant2_max_transferred = failsafe_addition(\r\n            participant2_transferred,\r\n            participant2_locked\r\n        );\r\n\r\n        // We enforce this check artificially, in order to get rid of hard\r\n        // to deal with over/underflows. Settlement balance calculation is\r\n        // symmetric (we can calculate either RmaxP1 and RmaxP2 first, order does\r\n        // not affect result). This means settleChannel must be called with\r\n        // ordered values.\r\n        require(participant2_max_transferred >= participant1_max_transferred, \"TNU: transfers not ordered\");\r\n\r\n        assert(participant1_max_transferred >= participant1_transferred);\r\n        assert(participant2_max_transferred >= participant2_transferred);\r\n\r\n        // This is the maximum amount that participant1 can receive at settlement time\r\n        participant1_net_max_received = (\r\n            participant2_max_transferred -\r\n            participant1_max_transferred\r\n        );\r\n\r\n        // Next, we add the participant1's deposit and subtract the already\r\n        // withdrawn amount\r\n        participant1_max_amount = failsafe_addition(\r\n            participant1_net_max_received,\r\n            participant1_deposit\r\n        );\r\n\r\n        // Subtract already withdrawn amount\r\n        (participant1_max_amount, ) = failsafe_subtract(\r\n            participant1_max_amount,\r\n            participant1_withdrawn\r\n        );\r\n        return participant1_max_amount;\r\n    }\r\n\r\n    function min(uint256 a, uint256 b) internal pure returns (uint256)\r\n    {\r\n        return a > b ? b : a;\r\n    }\r\n\r\n    function max(uint256 a, uint256 b) internal pure returns (uint256)\r\n    {\r\n        return a > b ? a : b;\r\n    }\r\n\r\n    /// @dev Special subtraction function that does not fail when underflowing.\r\n    /// @param a Minuend\r\n    /// @param b Subtrahend\r\n    /// @return Minimum between the result of the subtraction and 0, the maximum\r\n    /// subtrahend for which no underflow occurs\r\n    function failsafe_subtract(uint256 a, uint256 b)\r\n        internal\r\n        pure\r\n        returns (uint256, uint256)\r\n    {\r\n        return a > b ? (a - b, b) : (0, a);\r\n    }\r\n\r\n    /// @dev Special addition function that does not fail when overflowing.\r\n    /// @param a Addend\r\n    /// @param b Addend\r\n    /// @return Maximum between the result of the addition or the maximum\r\n    /// uint256 value\r\n    function failsafe_addition(uint256 a, uint256 b)\r\n        internal\r\n        pure\r\n        returns (uint256)\r\n    {\r\n        uint256 MAX_SAFE_UINT256 = (\r\n            115792089237316195423570985008687907853269984665640564039457584007913129639935\r\n        );\r\n        uint256 sum = a + b;\r\n        return sum >= a ? sum : MAX_SAFE_UINT256;\r\n    }\r\n\r\n    function recoverAddressFromBalanceProof(\r\n        uint256 chain_id,\r\n        uint256 channel_identifier,\r\n        bytes32 balance_hash,\r\n        uint256 nonce,\r\n        bytes32 additional_hash,\r\n        bytes memory signature\r\n    )\r\n        internal\r\n        view\r\n        returns (address signature_address)\r\n    {\r\n        // Length of the actual message: 20 + 32 + 32 + 32 + 32 + 32 + 32\r\n        string memory message_length = \"212\";\r\n\r\n        bytes32 message_hash = keccak256(abi.encodePacked(\r\n            signature_prefix,\r\n            message_length,\r\n            address(this),\r\n            chain_id,\r\n            uint256(MessageType.MessageTypeId.BalanceProof),\r\n            channel_identifier,\r\n            balance_hash,\r\n            nonce,\r\n            additional_hash\r\n        ));\r\n\r\n        signature_address = ECVerify.ecverify(message_hash, signature);\r\n    }\r\n\r\n    function recoverAddressFromBalanceProofCounterSignature(\r\n        MessageType.MessageTypeId message_type_id,\r\n        uint256 chain_id,\r\n        uint256 channel_identifier,\r\n        bytes32 balance_hash,\r\n        uint256 nonce,\r\n        bytes32 additional_hash,\r\n        bytes memory closing_signature,\r\n        bytes memory non_closing_signature\r\n    )\r\n        internal\r\n        view\r\n        returns (address signature_address)\r\n    {\r\n        // Length of the actual message: 20 + 32 + 32 + 32 + 32 + 32 + 32 + 65\r\n        string memory message_length = \"277\";\r\n\r\n        bytes32 message_hash = keccak256(abi.encodePacked(\r\n            signature_prefix,\r\n            message_length,\r\n            address(this),\r\n            chain_id,\r\n            uint256(message_type_id),\r\n            channel_identifier,\r\n            balance_hash,\r\n            nonce,\r\n            additional_hash,\r\n            closing_signature\r\n        ));\r\n\r\n        signature_address = ECVerify.ecverify(message_hash, non_closing_signature);\r\n    }\r\n\r\n    /* function recoverAddressFromCooperativeSettleSignature(\r\n        uint256 channel_identifier,\r\n        address participant1,\r\n        uint256 participant1_balance,\r\n        address participant2,\r\n        uint256 participant2_balance,\r\n        bytes signature\r\n    )\r\n        view\r\n        internal\r\n        returns (address signature_address)\r\n    {\r\n        // Length of the actual message: 20 + 32 + 32 + 32 + 20 + 32 + 20 + 32\r\n        string memory message_length = '220';\r\n\r\n        bytes32 message_hash = keccak256(abi.encodePacked(\r\n            signature_prefix,\r\n            message_length,\r\n            address(this),\r\n            chain_id,\r\n            uint256(MessageTypeId.CooperativeSettle),\r\n            channel_identifier,\r\n            participant1,\r\n            participant1_balance,\r\n            participant2,\r\n            participant2_balance\r\n        ));\r\n\r\n        signature_address = ECVerify.ecverify(message_hash, signature);\r\n    } */\r\n\r\n    function recoverAddressFromWithdrawMessage(\r\n        uint256 chain_id,\r\n        uint256 channel_identifier,\r\n        address participant,\r\n        uint256 total_withdraw,\r\n        uint256 expiration_block,\r\n        bytes memory signature\r\n    )\r\n        internal\r\n        view\r\n        returns (address signature_address)\r\n    {\r\n        // Length of the actual message: 20 + 32 + 32 + 32 + 20 + 32 + 32\r\n        string memory message_length = \"200\";\r\n\r\n        bytes32 message_hash = keccak256(abi.encodePacked(\r\n            signature_prefix,\r\n            message_length,\r\n            address(this),\r\n            chain_id,\r\n            uint256(MessageType.MessageTypeId.Withdraw),\r\n            channel_identifier,\r\n            participant,\r\n            total_withdraw,\r\n            expiration_block\r\n        ));\r\n\r\n        signature_address = ECVerify.ecverify(message_hash, signature);\r\n    }\r\n}\r\n"
    },
    "data/source/raiden/SecretRegistry.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity 0.7.6;\r\n\r\n/// @title SecretRegistry\r\n/// @notice SecretRegistry contract for registering secrets from Raiden Network\r\n/// clients.\r\ncontract SecretRegistry {\r\n    // sha256(secret) => block number at which the secret was revealed\r\n    mapping(bytes32 => uint256) private secrethash_to_block;\r\n\r\n    event SecretRevealed(bytes32 indexed secrethash, bytes32 secret);\r\n\r\n    /// @notice Registers a hash time lock secret and saves the block number.\r\n    /// This allows the lock to be unlocked after the expiration block\r\n    /// @param secret The secret used to lock the hash time lock\r\n    /// @return true if secret was registered, false if the secret was already\r\n    /// registered\r\n    function registerSecret(bytes32 secret) public returns (bool) {\r\n        bytes32 secrethash = sha256(abi.encodePacked(secret));\r\n        if (secrethash_to_block[secrethash] > 0) {\r\n            return false;\r\n        }\r\n        secrethash_to_block[secrethash] = block.number;\r\n        emit SecretRevealed(secrethash, secret);\r\n        return true;\r\n    }\r\n\r\n    /// @notice Registers multiple hash time lock secrets and saves the block\r\n    /// number\r\n    /// @param secrets The array of secrets to be registered\r\n    /// @return true if all secrets could be registered, false otherwise\r\n    function registerSecretBatch(bytes32[] memory secrets) public returns (bool) {\r\n        bool completeSuccess = true;\r\n        for(uint i = 0; i < secrets.length; i++) {\r\n            if(!registerSecret(secrets[i])) {\r\n                completeSuccess = false;\r\n            }\r\n        }\r\n        return completeSuccess;\r\n    }\r\n\r\n    /// @notice Get the stored block number at which the secret was revealed\r\n    /// @param secrethash The hash of the registered secret `keccak256(secret)`\r\n    /// @return The block number at which the secret was revealed\r\n    function getSecretRevealBlockHeight(bytes32 secrethash) public view returns (uint256) {\r\n        return secrethash_to_block[secrethash];\r\n    }\r\n}\r\n\r\n// MIT License\r\n\r\n// Copyright (c) 2018\r\n\r\n// Permission is hereby granted, free of charge, to any person obtaining a copy\r\n// of this software and associated documentation files (the \"Software\"), to deal\r\n// in the Software without restriction, including without limitation the rights\r\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\r\n// copies of the Software, and to permit persons to whom the Software is\r\n// furnished to do so, subject to the following conditions:\r\n\r\n// The above copyright notice and this permission notice shall be included in all\r\n// copies or substantial portions of the Software.\r\n\r\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\r\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\r\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\r\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\r\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\r\n// SOFTWARE.\r\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 1
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}